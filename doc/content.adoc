= Catacumba - Asynchronous web toolkit for Clojure.
Andrey Antukh, <niwi@niwi.be>
:toc: left
:numbered:
:source-highlighter: pygments
:pygments-style: friendly
:sectlinks:

== Introduction

_Catacumba_ is an asynchronous and non-blocking web tookit for Clojure build on top of
ratpack and netty. Is highly inspired by ratpack handlers approach with a little ideas from well
known ring.


== Rationale

I start writting this library as a research project for provide a simple an non obstructive
(a la ring) way to build asynchronous and non-blocking web services.

In clojure echosystem exists some solutions for that purpose: pedestal, aleph, and jet.
All them are good clojure libraries/frameworks but them does not satisfies me for different reasons:

* The pedestal approach is very opinionated and too much high level and I prefer something simple
  and lightweight.
* Aleph, seems a great library but lacks of documentation and its generic approach (not only http)
  not helps.
* Jet is a asynchronous ring addapter for jetty9. It is really great library that I have used in
  some projects, and fits very well on my idea of web toolkit but it has two drawbacks, it is build
  as ring adapter having all the good and all the bad of ring and it is using jetty (jetty is a
  servlet server that comes with optional async support, it isn't asynchronous from the ground up).

Here a incomplete list of things that _Catacumba_ intends to have:

- a flexible and extensible way to setup different kind of handlers.
- build almost everything up on abstractions for easy extensibility.
- support for async handlers (with promise, future, core.async, manifold, reactive-streams, ...)
- builtin routing with flexible way to chain henlers.
- builtin websocket support.
- backpressure support out of the box.


=== Goals

_Catacumba_ goals are:

* Provide a simple and lighweight aproach for define asynchronous web services.
* Add facilities for work in asynchronous way without much pain.
* To be flexible and not very opinionated.
* Provide the basic abstractions (handlers, routing, websockets, ...).

_Catacumba_ goals are not:

* To by a fully integrated full stack solution like immutant or pedestal.
* Provide a opinionated way to structure your "bussines logic"
* Provide all possible features that you might need.
* Low level, ring based library.


== Project Maturity

Since _catacumba_ is a young project there can be some API breakage.


== Install

This section covers the _catacumba_ library installing process and its requirements.


=== Requirements

_Catacumba_ is only runs with *JDK8* and *Clojure 1.7+* (due to extensive use of transducers
and jdk8 concurrency primitives).


=== Leiningen

The simplest way to use _catacumba_ in a clojure project, is by including it in the dependency
vector on your *_project.clj_* file:

._on project.clj_
[source,clojure]
----
[funcool/catacumba "0.1.0-SNAPSHOT"]
----


=== Gradle

If you are using gradle, this is a dependency line for gradle dsl:

[source, groovy]
----
compile "funcool:catacumba:0.1.0-SNAPSHOT"
----


=== Get the Code

_catacumba_ is open source and can be found on link:https://github.com/funcool/catacumba[github].

You can clone the public repository with this command:

[source,text]
----
git clone https://github.com/funcool/catacumba
----


== Quick Start

This section intends to explain how to get _Catacumba_ up and running.

=== First handler

The handler consists in a function that accepts a "context" as first parameter and
returns something rederable. Let see an example:

[source, clojure]
----
(defn my-hello-world-handler
  [context]
  "Hello World")
----


=== Run the server

Now having defined the simple, hello world handler, it is time to run it. For it
import the `run-server` function from `catacumba.core` ns and execute it with
handler as first parameter:

[source, clojure]
----
(require '[catacumba.core :as ct])

(ct/run-server my-hello-world-handler)
----

TIP: The `run-server` function does not blocks and you can execute it in a repl without
problems. It uses jvm not daemon threads for avoid shutdown the jvm.


== Handlers

The handlers is a fundamental piece of the _Catacumba_ library and this chapter intends
to explain everything related to defult handlers.


=== What is a handler?

As we have viewed in "Quick Start" section, a handler mainly consists in a simple function
that acts on the handling context.

Do not worry about the context, it will be explained in below sections. The only thing that you
shoult known about context at this time, that is the central part of the request and response
lifetime. It stores the current state of the http request and everything related.

The hello world handler has this aspect:

[source, clojure]
----
(defn myhandler
  [ctx]
  "Hello World")
----

NOTE: I mention the "default" word because, _catacumba_ comes with different types of
handlers out of the box and allows to be extended with used defined ones.


=== Write to response

As you can observe from the previous example, no status code is provided, only the content. For
send a complete response you can use a builtin response type or ring like hashmap:

[source, clojure]
----
(require '[catacumba.http :as http])

(defn my-handler
  [ctx]
  (http/ok "Hello Workd"))
----

This is a list of supported output values:

- a *string*, that will result in a response with 200 status code and "text/plain" as content type.
- a *ring style* hash map.
- a *response* type (very similar to ring one)


The handler's return value is implemented using clojure protocols and its behavior can be extended
easily with user defined types.

Let see an other example, using _catacumba_'s response type with additional header:

[source, clojure]
----
(require '[catacumba.http :as http])

(defn myhandler
  [ctx]
  (http/ok "<p>Hello Workd</p>" {:content-type "text/html"}))
----

An other core part of the _catacumba_ (like in ratpack) is the *Context*. Is the central
part of the request/response lifetime. It also has other responsabilities but are out of
scope of this section.

In the previous examples, we have seen how the return value is handled, but behind the scenes
the context is the responsible of interactions with the request and the response. Let see the
same example but interacting directly with context:

[source, clojure]
----
(def myhandler
  [ctx]
  (ct/set-status! ctx 200)
  (ct/set-headers! ctx {:content-type "text/plain"})
  (ct/send! ctx "hello world"))
----

The return value handling is really a helper for people that comes from ring. Internally, the
context is the main protagonist in IO operations.


=== Reading the request

As we mentioned previously, the request can be retrieved also from context instance. But in our case,
catacumpa provides helpers functions for access to the basic parts how the request body, incoming
headers, cookies and routing tokens.

You can access to the request object using `get-request` function. But, in almost all situations you
do not need it because the _catacumba_ api is polymorphic and you cann access to almost all basic
properties from request using a context as parameter, removing the repeating action of extracting
the request form context.


==== Body

_Catacumba_ offers different ways to read the incoming data from request. All depens on that really
you needs. If you are working with standatd http form submits (with `application/x-www-form-urlencoded`
or `multipart/form-data`), you should use the `parse-formdata` helper function:

[source, clojure]
----
(def myhandler
  [context]
  (let [formdata (ct/parse-formdata context)]
    (do-something-with-formdata formdata)
    (http/ok "Readed for data correctly")))
----

The return value of `parse-formdata` is a clojure map with parsed key value pairs, including files
uploaded with `multipart/form-data` content type.

In other some situations we need more low level access to the body. In this case, you can obtain a
object instance that represents a body using the `get-body` function. The return value of that function
implements the convenient protocols from `clojure.java.io` namespace, then you can use it for create
a apropiate reader or input stream depending of you needs. Also, for convenience, the request and
context instances also implements that protocol for make things more easy.

A good demostration of it, is using the clojure `slurp` function. It uses `clojure.java.io` abstractions
behind the scenes and seerves as helper for read some resource as string:

[source, clojure]
----
(def myechohandler
  [context]
  (let [body (slurp context)]
    (http/ok body)))
----

If you know the behavior of slurp, it reads the content of the provided resource as string and return
it.


==== Headers

For extract headers you should use the `get-headers` function. Like as usual, is a polymorphic function
and you could use it over context instance without problems. The return value is a clojure map.

If a header has multiple values, the value will be a vector.


==== Cookies

TBD


== Routing

In difference to ring, _catacumba_ is a toolkit for web development and offers builtin support for
advanced routing that allows handlers chaining, partitioning, error handling, among others.

_Catacumba_ has polymorphic and extensible way to setup handlers, and routing is one of possible
implementations. Is completelly optional and you can use any ther routing library if you want.

=== Basic syntax

The routes in _catacumba_ are defined using clojure data structures, using vectors and keywords. Let
see a little example of the aspect in a complete example:

[source, clojure]
----
(def routes
  (ct/routes [[:prefix "api"
               [:get "users" users-handler]]]))

(ct/run-server routes)
----

The order of statemens is very important because the routing in _catacumba_ is a simple chain or in
other words: pipeline. The handlers has the ability to delegate the request handign to the next
handler in the pipeline. If you know the *pedestal* interceptors concept, this is maybe also
familiar for you.


=== Handlers chaining

The chaining of handlers can be done in different ways:

- *inline*: providing more that one handler for concrete http method.
- *multiple route*: providing a "match all" handlers at the start of prefix.

The inline handlers chaining has this aspect:

[source, clojure]
----
(ct/routes [[:get "users" permission-check-handler get-users-handler]])
----

And as all the route is a chain/pipeline, you can setup "catch all" handlers at the start and use
them as interceptors:

[source, clojure]
----
(def routes
  (ct/routes [[:prefix "api"
               [:all authentication-handler]
               [:get "users" users-handler]]]))
----

For better understanding how the handlers chain delegation works, see the *Context* chapter
of this documentation.


=== Error handling

The _catacumba_ router chain allows setup user defined error handling functions. Do it is very
simple, just add an other route entry of `:error` type:

[source, clojure]
----
(def routes
  (ct/routes [[:error my-error-handler]
              [:get "users" users-handler]]))
----

With previous code we have set a global (for all handlers in a route chain) error handler. But
there also possible set different error handlers for different prefixes:

[source, clojure]
----
(def routes
  (ct/routes [[:prefix "api"
               [:error my-error-handler-for-this-prefix]
               [:all authentication-handler]
               [:get "users" users-handler]
               [:put "users" check-permissions-handler update-users-hander]]
              [:prefix "statix"
               [:error my-error-handler-for-this-other-prefix]
               [:assets "public"]]]))
----

The error handler aspect is very similar to standard http handler, the difference is that it receives
additional parameter the throwable instance:

[source, clojure]
----
(defn my-error-hanlder
  [ctx error]
  (http/internal-server-error (.getMessage error)))
----


== Context

An other core part of the _catacumba_ is the *Context*. 

The context in catacumba as in ratpack has this responsabilities:

* Provide direct access to the request and response objects.
* Access to the contextual objects (called registry).
* Flow control in handler chaining.
* Convenience helpers for common handlers operation.


=== Contextual objects

TBD


=== Handlers delegation

In _catacumba_, the request is handled using a chain of handlers. And one concrete handler can decide
delegate tha work to the next matching handler in the chain. Probably, you have seen the different ways of chaining handlers in the router section, in this section we will see how we can delegate the request
handling to the next matching handler.

The delegation action can be done with `delegate` multiarity function. Let see a simple example:

[source, clojure]
----
(defn handler1
  [context]
  (do-something context)
  (ct/delegate context))

(defn handler2
  [context]
  (http/ok "hello world"))

(def router
  (ct/routes [[:get "foo" handler1 handler2]]))
----

In this example, when request arrives to handler1, it delegates it to the next possible handler. It do
not know about it, it just delegates to the next.

Additionally to the simple handlers delegation, _catacumba_ offers a simple way to pass context data
to the next handlers, passing additional parameter to the `delegate` function:

[source, clojure]
----
(defn handler1
  [context]
  (do-something context)
  (ct/delegate context {:message "foobar"}))

(defn handler2
  [context]
  (let [data (ct/context-params context)]
    (http/ok (:message data "hello world"))))
----

In this example the second handler prints the message found in the context.


== Asynchronous Handlers

_Catacumba_ has support for multiple abstractions for asynchronous (stream or not) abstractions and
addopts a flexible and extensible way for make easy for the user adapt it to hes needs and hes
abstractions.

The main abstraction are defined in the link:https://github.com/funcool/futura[futura library], 
that provides basic building blocks for promise like abstractions and stream abstraction.

The link:https://github.com/funcool/futura[futura library] instead of reinvent the wheel, is build 
up on existing implementations such as:

* _JDK8 CompletableFuture_ for *promise* abstraction.
* _Reactive Streams_ for the *stream* abstraction.

Using the link:http://www.reactive-streams.org/[reactive streams] instead of reinvent yet another
stream abstraction has huge amount of advantages. There three most important:

* Interoprability with all libraries that has support for reactive streams
* Well and strongly defined behavior of the abstraction.
* Comes with support for *backpressure* in its core (that is mandatory in asynchronous environments).


=== Channels

The `core.async` channels is one of the supported abstractions that is supported by _catacumba_ out
of the box. It consists in a handler that returns a body as a channel or response as a channel.

This is the aspect of async handler returning the channel as a body:

[source, clojure]
----
(defn my-async-handler
  [context]
  (let [ch (chan)]
    (go
      (dotimes [i 10]
        (<! (timeout 500))
        (>! ch (str i "\n")))
      (close! ch))
    (http/ok ch)))
----

Returning channel as a body has the advantage that you have the ability of set additional
headers and returning code. But, if you are return a channel as a response value, the default
status code will be set for you. The behavior of two approaches is the same, resultin in a chunked
encoded response to the client.

And this is the aspect of async handler returning channel as response:

[source, clojure]
----
(defn my-async-handler
  [context]
  (go
    (let [result (<! (do-some-async-task))]
      (:message result)))
----

Do not worry about how data you can send to the client, if you are using channels in a right way
in a go block, yo will send data to the client as fast as client can consume it. This technique is
also called backpressure, and is fully supported for chunked responses.

NOTE: Behind the scenes it adapts the channel into link:http://www.reactive-streams.org/[Reactive Streams] `Publisher`.


=== Promises

Promises is an other abstraction supported out of the box in _catacumba_. It comes from the
link:https://github.com/funcool/futura[futura library] and is build on top of JDK8 _CompletableFuture_.

Sometimes, yo do not need send a chunked stream to the clien, but your "bussines logic" is defined
with asynchronous friendly api using promises (or something similar). In this case, with _catacumba_
you can return a promise as a body or as a response and the data will be sent to the client when
the promise is successfully resolved.

[source, clojure]
----
(require '[futura.promise :as p])

(defn my-async-handler
  [context]
  (let [promise (p/promise "hello world")]
    (http/ok promise {:content-type "text/plain"})))
----

Thanks to the *future* library internals, we can use it with 
link:https://github.com/funcool/cats[cats] `mlet` macro, that allows us structure pure async 
code in a synchronous way:

[source, clojure]
----
(require '[futura.promise :as p])
(require '[cats.core :as m])

(defn my-async-handler
  [context]
  (m/mlet [a (something-that-return-promise context)
           b (do-something-with a)]
    (do-other-thing-with b)))
----

The result of `mlet` macro expression will be a *promise* with the eventually available result
from `(do-other-thing-with b)` expression.


=== Futures

As previously explained promises are build on top of *CompletableFutures* of JDK8, _catacumba_ also
supports the raw usage of them:

[source, clojure]
----
(defn my-async-handler
  [context]
  (-> (something-that-returns-completable-future context)
      (http/ok {:content-type "text/plain"})))
----


=== Manifold

The link:https://github.com/ztellman/manifold[maniforld] library offers different kind of deferred and
stream abstractions for clojure.

I'm not very fan of it due to the lacks of good and easy readable documentation and its very complex
implementation. But is one of the most mature libraries in clojure ecosystem.

WARNING: support for manifold is not stil not implemented.


=== Reactive Streams

This is the core of all abstractions, and support for it comes out of the box from *ratpack*. All
other abstractions that we have seen are always coerced to *Publisher* instance before send it to the
client.

Here nothing new to explain, if you have a function that return some kind of publisher, you can return
it as response or send it as body like as usual.

The adaptations and coerciones are done thanks to the
link:https://github.com/funcool/futura[futura library] that has more adaptations supported out of the
box that which are comming with _catacumba_.

Let see an example:

[source, clojure]
----
(require '[futura.stream :as stream])
(require '[cuerdas.core :as str])

(defn my-async-handler
  [context]
  (let [pub (->> (stream/publisher ["hello" " " "world"])
                 (stream/publisher (map str/upper)))]
    (http/ok pub)))

;; It will return a chunked response to the client with "HELLO WORLD" string.
----

Reactive streams implementation in link:https://github.com/funcool/futura[futura library] comes with
support for different kind of coercions and with clojure 1.7 *transducers*.


== Websockets

One of the main goals of _catacumba_ is come with builtin, full featured and backpressure aware
websockets support.

You can start a websocket connection in any _catacumba_ handler or route handler using `websocket`
function. It not need special handlers for treat websockets. Let see an example:

[source, clojure]
----
(defn my-websocket-echo-handler
  [{:keys [in out]}]
  (go-loop []
    (if-let [received (<! in)]
      (do
        (>! out received)
        (recur))
      (close! out))))

(defn my-handler
  [context]
  (ct/websocket context my-websocket-echo-handler))

(def route
  (ct/routes [[:prefix "events"
               [:all my-handler]]]))
----

It is very simple, you can use a plain handlers or handlers attached in a route chain with the ability
to start websocket connection in any place.

Additionally, _catacumba_ offers a a way to setup websocket handler directly, without additional step
on standard handler:

[source, clojure]
----
(defn echo-handler
  "This is my echo handler that serves as
  a websocket handler example."
  {:type :websocket}
  [{:keys [in out]}]
  (go-loop []
    (if-let [received (<! in)]
      (do
        (>! out received)
        (recur))
      (close! out))))

(def route
  (ct/routes [[:prefix "events"
               [:all echo-handler]]]))
----

TIP: The handlers adaptation is driven by its metadata and is defined using clojure multimethods. It allows you define own adapters for websockets or any other handlers if the builtin does not satisfies you.

== Ring

Although ring support is not first citizen in _catacumba_, the current design of it allows create an
handler adapter that follows the ring specification. This is a great example of extensibility of
_catacumba_.

Let see how it can be done:

[source, clojure]
----
(defn myringhandler
  "My example ring handler."
  {:type :ring}
  [request]
  {:status 200
   :body "hello world"})

;; As standalone handler
(ct/run-server myringhandler)

;; Or in a _catacumba_ routing chain
(-> (ct/routes [[:get myringhandler]])
    (ct/run-server))
----

Ring handlers can be set as standalone handlers (mainly for use them as compojure and all related
middlewares) or in a _catacumba_'s routing chain.


== Launching the server

As you can see in the quick start section, the main entry point for start the server is
the `run-server` function that receives a handler and a map with options.

At this moment, it has a very little subset of options that netty and ratpack offers but is good
start point.

.Supported options
[options="header", cols="^1,^1,^2"]
|===========================================================================
| Keyword   | Default | Description
| `:port`   | `5050` | The port to listen on.
| `:threads` | (num of cores * 2) | The number of threads for handler requests.
| `:debug` | `true` | Start in development mode.
| `:setup` | nil    | A callback for configuration step (low level ratpack access).
| `:basedir` | nil | The application base directory, used mainly for resolve relative paths and assets.
|===========================================================================

All supported options of this function, can be overwritten on jvm startup, using environment variables
or system properties. This allows customize the server out of source code and exists for convenience
for make easy customizations in deployments.

For example, you can change the default port on jvm startup using `CATACUMBA_PORT` environment variable
or `catacumba.port` system property:

.Example using enviroment variables
[source, bash]
----
export CATACUMBA_PORT=8000
export CATACUMBA_BASEDIR=`pwd`
java -jar yourjarhere.jar
----

.Example using enviroment variables
[source, bash]
----
java -Dcatacumba.port=8000 -Dcatacumba.debug=false -jar yourjarhere.jar
----


== FAQ

TBD


== How to Contribute?

=== Philosophy

Five most important rules:

- Beautiful is better than ugly.
- Explicit is better than implicit.
- Simple is better than complex.
- Complex is better than complicated.
- Readability counts.

All contributions to _catacumba_ should keep these important rules in mind.


=== Procedure

**catacumba** unlike Clojure and other Clojure contrib libs, does not have many
restrictions for contributions. Just follow the following steps depending on the
situation:

**Bugfix**:

- Fork the GitHub repo.
- Fix a bug/typo on a new branch.
- Make a pull-request to master.

**New feature**:

- Open new issue with the new feature proposal.
- If it is accepted, follow the same steps as "bugfix".


== License

_catacumba_ is licensed under BSD (2-Clause) license:

----
Copyright (c) 2015, Andrey Antukh <niwi@niwi.be>

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
----
