= Catacumba - Web toolkit for Clojure.
Andrey Antukh, <niwi@niwi.be>
:toc: left
:!numbered:
:idseparator: -
:idprefix:
:source-highlighter: pygments
:pygments-style: friendly
:sectlinks:


== Introduction

_Catacumba_ is an asynchronous and non-blocking web toolkit for Clojure built on top of
ratpack and netty. Is highly inspired by ratpack handlers approach with a little ideas from the
well known ring.


=== Rationale

I start writting this library as a research project for provide a simple an non obstructive
(a la ring) way to build asynchronous and non-blocking web services.

In clojure ecosystem there are several solutions for that purpose: pedestal, aleph, and jet.
All them are good clojure libraries/frameworks but them does not satisfies me for different reasons:

* The pedestal approach is very opinionated and too much high level and I prefer something simple,
  lightweight and maybe less opinionated.
* Aleph, seems a great library but lacks of good, readable, user friendly documentation and
  its generic approach (not only http) not helps much. If you want read more about differences with
  aleph, see <<difference-with-aleph,this>> faq entry.
* Jet is a asynchronous ring addapter for jetty9. It is really great library that I have used in
  some projects, and fits very well on my idea of web toolkit but it has two drawbacks, it is build
  as ring adapter having all the good and all the bad of ring and it is using jetty (jetty is a
  servlet server that comes with optional async support, it isn't asynchronous from the ground up).


=== Goals

Here a incomplete list of things that _catacumba_ goals:

* Have a flexible and extensible way to setup different kind of handlers
* Provide a simple and lightweight approach for define asynchronous web services with support for
  different abstractions, such as promise, future, core.async, manifold, reactive-streams, ...
* Build almost everything up on abstractions for simple and easy extensibility.
* Provide a builtin, data based routing.
* To be flexible and not very opinionated.
* Have backpressure support out of the box.

_Catacumba_ goals are not:

* To by a fully integrated full stack solution like immutant or pedestal.
* Provide a opinionated way to structure your "bussines logic"
* Provide all possible features that you might need.
* Low level, ring based library.


=== Project Maturity

Since _catacumba_ is a young project there can be some API breakage.


=== Requirements

_Catacumba_ is only runs with *JDK8* and *Clojure 1.7+* (due to extensive use of transducers
and jdk8 concurrency primitives).


=== Install

This section covers the _catacumba_ library installing process and its requirements.

*Leiningen*

The simplest way to use _catacumba_ in a clojure project, is by including it in the dependency
vector on your *_project.clj_* file:

[source,clojure]
----
[funcool/catacumba "0.2.0"]
----

*Gradle*

If you are using gradle, this is a dependency line for gradle dsl:

[source, groovy]
----
compile "funcool:catacumba:0.2.0"
----


== Quick Start

This section intends to explain how to get _catacumba_ up and running.


=== First handler

The handler consists in a function that accepts a "context" as first parameter and
returns something renderable. Let see an example:

[source, clojure]
----
(defn my-hello-world-handler
  [context]
  "Hello World")
----

The handler maybe looks very familiar if you are previously have used ring, the main difference
is that it receives some kind of context object instead of request. And may return a string directly.

All of related concepts and full introduction on how the handlers works are explained in below sections.


=== Run the server

Now having defined the simple, hello world handler, it is time to run it. For it
import the `run-server` function from `catacumba.core` ns and execute it with
handler as first parameter:

[source, clojure]
----
(require '[catacumba.core :as ct])

(ct/run-server my-hello-world-handler)
----

TIP: The `run-server` function does not blocks and you can execute it in a repl without
problems. It uses jvm not daemon threads for avoid shutdown the jvm.


=== Complete example

It there the complete source code of the example:

[source, clojure]
----
(ns exampleapp.core
  (:require [catacumba.core :as ct])
  (:gen-class))

(defn my-hello-world-handler
  [context]
  "Hello World")

(defn -main
  [& args]
  (ct/run-server my-hello-world-handler))
----


_Catacumba_ comes with a little collection of <<examples,Examples>> that may help
you setup your first project.


== User Guide

This section intends explain all the different parts of _catacumba_ and
how they are run together.


=== Handlers

The handlers is a fundamental piece of the _catacumba_ library and this chapter intends
to explain everything related to defult handlers.


==== What is a handler?

As we have viewed in "Quick Start" section, a handler mainly consists in a simple function
that acts on the handling context.

Do not worry about the context, it will be explained in below sections. The only thing that you
shoult known about it at this time, is that is the central part of the request and response
lifetime. It stores the current state of the http request and everything related.

The hello world handler has this aspect:

[source, clojure]
----
(defn myhandler
  [context]
  "Hello World")
----

NOTE: I mention the "default" word because, _catacumba_ comes with different types of
handlers out of the box and allows to be extended with used defined ones.


==== Write to response

As you can observe from the previous example, no status code is provided, only the content. For
send a complete response you can use a builtin response type or ring like hashmap:

[source, clojure]
----
(require '[catacumba.http :as http])

(defn my-handler
  [context]
  (http/ok "Hello World"))
----

This is a list of supported output values:

- a *string*, that will result in a response with 200 status code and "text/plain" as content type.
- a *ring style* hash map.
- a *response* type (very similar to ring one)

The handler's return value is implemented using clojure protocols and its behavior can be extended
easily with user defined types.

Let see an other example, using _catacumba_'s response type with additional header:

[source, clojure]
----
(require '[catacumba.http :as http])

(defn myhandler
  [context]
  (http/ok "<p>Hello World</p>" {:content-type "text/html"}))
----

In the previous examples, we have seen how the return value is handled, but behind the scenes
the context is the responsible of interactions with the request and the response. Let see the
same example but interacting directly with context:

[source, clojure]
----
(def myhandler
  [context]
  (ct/set-status! context 200)
  (ct/set-headers! context {:content-type "text/plain"})
  (ct/send! context "hello world"))
----

The return value handling is really a helper for people that comes from ring. Internally, the
context is the main protagonist in IO operations.


==== Reading the request

As we mentioned previously, the request can be retrieved also from context instance. But in our case,
catacumpa provides helpers functions for access to the basic parts how the request body, incoming
headers, cookies and routing tokens.

You can access to the request object using `get-request` function. But, in almost all situations you
do not need it because the _catacumba_ api is polymorphic and you cann access to almost all basic
properties from request using a context as parameter, removing the repeating action of extracting
the request form context.


===== Body

For access to the request body, _catacumba_ exposes a `get-body` function. That function returns a
ratpack link:http://ratpack.io/manual/current/api/ratpack/http/TypedData.html[internal type] that
represents a body.

That object exposes through java interop methods for access to the conten type and the raw data. For
convenience it also implements necesarry protocols of `clojure.java.io` namespace for make it
compatible with clojure facilities for read data.

A good demostration of it, is using the clojure `slurp` function. It uses `clojure.java.io` abstractions
behind the scenes and serves as helper for read some resource as string:

[source, clojure]
----
(def myechohandler
  [context]
  (let [^String body (slurp (ct/get-body context))]
    (http/ok body)))
----

If you don't know the behavior of slurp, it reads the content of the provided resource as string
and return it.

Furthermore, _catacumba_ offers more flexible way to parsing body data based on the incoming
content type, but it is explained with more details in the <<body-parsing,handlers section>>.


===== Headers

For extract headers you should use the `get-headers` function. Like as usual, is a polymorphic function
and you could use it over context instance without problems. The return value is a clojure map.

If a header has multiple values, the value will be a vector.

[source, clojure]
----
(ct/get-headers context)
;; => {:content-type ...}
----


===== Cookies

The cookies crud operations works very similiar to the headers one. It consists in two polymorphic
functions (`get-cookies` and `set-cookies!`) that can be used directly with context or with request
or response instances.

.Get cookies from request example
[source, clojure]
----
(ct/get-cookies context)
;; => {:cookiename {:value "value" :path "/" :secure false}}
----

.Set cookies to the response
[source, clojure]
----
(ct/set-cookies context {:cookiename {:value "foobar" :max-age 3600}})
----

The cookies map is almost identical to that you can found in ring, and has the following possible
properties:

* `:domain` - restrict the cookie to a specific domain
* `:path` - restrict the cookie to a specific path
* `:secure` - restrict the cookie to HTTPS URLs if true
* `:http-only` - restrict the cookie to HTTP if true
                 (not accessible via e.g. JavaScript)
* `:max-age` - the number of seconds until the cookie expires


=== Routing

In difference to ring, _catacumba_ is a toolkit for web development and offers builtin support for
advanced routing that allows handlers chaining, partitioning, error handling, among others features.

NOTE: _Catacumba_ has polymorphic and extensible way to setup handlers, and routing is one of possible
implementations. Is completelly optional and you can use any other routing library if you want.


==== Basic syntax

The routes in _catacumba_ are defined using clojure data structures: vectors and keywords. Let
see a little example of the aspect in a complete example:

[source, clojure]
----
(def routes
  (ct/routes [[:prefix "api"
               [:get "users" users-handler]]]))

(ct/run-server routes)
----

The order of statemens is very important because the routing in _catacumba_ is a simple chain or in
other words: pipeline. The handlers has the ability to delegate the request handign to the next
handler in the pipeline.

This is a complete list of route directives that you can use a part of `:get`:  `:any` (matches all
routes, often used for add chain handlers), `:post`, `:put`, `:patch` and `:delete`.


==== Dispatch by method

In some circumstances you may want have different handlers depending on the http method used
for one concrete endpoint. For it exists the `:by-method` route directive:

[source, clojure]
----
(ct/routes [:prefix "api"
            [:by-method "users"
             [:get list-users-handler]
             [:post create-users-handler]]])
----


==== Routing params

The _catacumba_'s routing also allows capture url parameters using special symbols. For example,
the path string "foo/:val" will match paths such as "foo/bar", "foo/123".  The matched parameters
are automatically populated to the context under the `:route-params` keys.

[source, clojure]
----
(def article-detail
  [context]
  (let [id (get-in context [:route-params :id])]
    (http/ok (str "You have requested article with id=" id))))

(def app
  (ct/routes [[:get "articles/:id" article-detail]]))
----

Additionally to the basic token for represent the url parameter, _catacumba_ also allows use of
regular expressions for delimit the input or mark a url token optional.

See the following table for all supported url tokens:

.Supported url matching tokens
[options="header", cols="2,3,3,2"]
|===========================================================================
| Path Type | Syntax | Route example | Matching url example
| Literal | `foo` | `[:get "foo" handler]` | `/foo`
| Mandatory | `:«token-name»` | `[:get "foo/:param" handler]` | `/foo/bar`
| Optional | `:«token-name»?` | `[:get "foo/:param?" handler]` | `/foo` and `/foo/bar`
| Mandatory & Regex | `:«token-name»:«regex»` | `[:get "foo/:id:\d+" handler]` | `/foo/2`
| Optional & Regex | `:«token-name»?:«regex»` | `[:get "foo/:id?:\d+" handler]` | `/foo/2` and `/foo`
|===========================================================================


==== Routing chain

The chaining of handlers can be done in different ways:

- *inline*: providing more that one handler for concrete http method.
- *multiple route*: providing a "match all" handlers at the start of prefix.

The inline handlers chaining has this aspect:

[source, clojure]
----
(ct/routes [[:get "users" permission-check-handler get-users-handler]])
----

Also, you can setup "catch all" handlers at the start and use them as interceptors:

[source, clojure]
----
(def routes
  (ct/routes [[:prefix "api"
               [:any authentication-handler]
               [:get "users" users-handler]]]))
----

For better understanding how the handlers chain delegation works, see the *Context* chapter.


==== Error handling

The _catacumba_ router chain allows setup user defined error handling functions. Do it, is very
simple, just add an other route entry with `:error` route directive:

[source, clojure]
----
(def routes
  (ct/routes [[:error my-error-handler]
              [:get "users" users-handler]]))
----

With previous code we have set a global (for all handlers in a route chain) error handler. But
there also possible set different error handlers for different prefixes:

[source, clojure]
----
(def routes
  (ct/routes [[:prefix "api"
               [:error my-error-handler-for-this-prefix]
               [:any authentication-handler]
               [:get "users" users-handler]
               [:put "users" check-permissions-handler update-users-hander]]
              [:prefix "admin"
               [:error my-error-handler-for-this-other-prefix]
               [:get "dashboard" my-dashboard-handler]]]))
----

The error handler aspect is very similar to standard http handler, the difference is that it receives
additional parameter the throwable instance:

[source, clojure]
----
(defn my-error-handler
  [context error]
  (http/internal-server-error (.getMessage error)))
----


=== Context

An other core part of the _catacumba_ is the *Context*.

The context in catacumba as in ratpack has this responsabilities:

* Provide direct access to the request and response objects.
* Access to the contextual objects (called registry).
* Flow control in handler chaining.
* Convenience helpers for common handlers operation.


==== Handlers delegation

In _catacumba_, the request is handled using a chain of handlers. And one concrete handler can decide
delegate tha work to the next matching handler in the chain. Probably, you have seen the different ways of chaining handlers in the router section, in this section we will see how we can delegate the request
handling to the next matching handler.

The delegation action can be done with `delegate` multiarity function. Let see a simple example:

[source, clojure]
----
(defn handler1
  [context]
  (do-something context)
  (ct/delegate context))

(defn handler2
  [context]
  (http/ok "hello world"))

(def router
  (ct/routes [[:get "foo" handler1 handler2]]))
----

In this example, when request arrives to handler1, which delegates the execution to the next
handler in the chain. It do not know about next handler, it just delegates to the routing chain
to find a next handler or raise corresponding error.

Additionally to the simple handlers delegation, _catacumba_ offers a simple way to pass context data
to the next handlers. It can be done passing additional parameter to the `delegate` function:

[source, clojure]
----
(defn handler1
  [context]
  (do-something context)
  (ct/delegate context {:message "foobar"}))

(defn handler2
  [context]
  (let [message (:message context)]
    (http/ok message)))
----

In this example the second handler prints the message found in the context.


=== Asynchronous Handlers

Asynchronous handlers are handlers that return a value in asyncrhonous way using one of the
supported abstractions, such as core.async, reactve-streams and much others (explained below).


==== Channels

The `core.async` channels is one of the supported abstractions that comes with _catacumba_ out
of the box. It consist in a handler that returns a body as a channel or response as a channel.

This is the aspect of async handler returning the channel as a body:

[source, clojure]
----
(defn my-async-handler
  [context]
  (let [ch (chan)]
    (go
      (dotimes [i 10]
        (<! (timeout 500))
        (>! ch (str i "\n")))
      (close! ch))
    (http/ok ch)))
----

Returning channel as a body has the advantage that you have the ability of set additional
headers and returning code. But, if you are return a channel as a response value, the default
status code will be set for you. The behavior of two approaches is the same, resultin in a chunked
encoded response to the client.

And this is the aspect of async handler returning channel as response:

[source, clojure]
----
(defn my-async-handler
  [context]
  (go
    (let [result (<! (do-some-async-task))]
      (:message result)))
----

Do not worry about how much data you can send to the client, if you are using channels in a right way
(in a go block), yo will send data to the client as fast as client can consume it. This technique is
also called backpressure, and is fully supported for chunked responses.


==== Promises

Promises is an other abstraction supported out of the box in _catacumba_. It comes from the
link:https://github.com/funcool/futura[futura library] and is build on top of JDK8 _CompletableFuture_.

Sometimes, yo do not need send a chunked stream to the clien, but your "bussines logic" is defined
with asynchronous friendly api using promises (or something similar). In this case, with _catacumba_
you can return a promise as a body or as a response and the data will be sent to the client when
the promise is successfully resolved.

[source, clojure]
----
(require '[futura.promise :as p])

(defn my-async-handler
  [context]
  (let [promise (p/promise "hello world")]
    (http/ok promise {:content-type "text/plain"})))
----

Thanks to the *future* library internals, we can use it with
link:https://github.com/funcool/cats[cats] `mlet` macro, that allows us structure pure async
code in a synchronous way:

[source, clojure]
----
(require '[futura.promise :as p])
(require '[cats.core :as m])

(defn my-async-handler
  [context]
  (m/mlet [a (something-that-return-promise context)
           b (do-something-with a)]
    (do-other-thing-with b)))
----

The result of `mlet` macro expression will be a *promise* with the eventually available result
from `(do-other-thing-with b)` expression.


==== Futures

As previously explained promises are build on top of *CompletableFutures* of JDK8, _catacumba_ also
supports the raw usage of them:

[source, clojure]
----
(defn my-async-handler
  [context]
  (-> (something-that-returns-completable-future context)
      (http/ok {:content-type "text/plain"})))
----


==== Manifold

The link:https://github.com/ztellman/manifold[manifold] library offers different kind of deferred and
stream abstractions for clojure and you can use both them as response or body of the response for send
asynchronously data to the client.

[source, clojure]
----
(require '[manifold.deferred :as d])

(defn my-async-handler
  [context]
  (let [result (d/future (Thread/sleep 1000) "hello world")]
    (http/ok result {"content-type" "text/plain"})))
----


==== Reactive Streams

This is the core of all abstractions, and support for it comes out of the box from *ratpack*. All
other abstractions that we have seen are always coerced to *Publisher* instance before send it to the
client.

Here nothing new to explain, if you have a function that return some kind of publisher, you can return
it as response or send it as body like as usual.

The adaptations and coerciones are done thanks to the
link:https://github.com/funcool/futura[futura library] that has more adaptations supported out of the
box that which are comming with _catacumba_.

Let see an example:

[source, clojure]
----
(require '[futura.stream :as stream])
(require '[cuerdas.core :as str])

(defn my-async-handler
  [context]
  (let [pub (->> (stream/publisher ["hello" " " "world"])
                 (stream/publisher (map str/upper)))]
    (http/ok pub)))

;; It will return a chunked response to the client with "HELLO WORLD" string.
----

Reactive streams implementation in link:https://github.com/funcool/futura[futura library] comes with
support for different kind of coercions and with clojure 1.7 *transducers*.


=== WebSockets

One of the main goals of _catacumba_ is come with builtin, full featured and backpressure aware
websockets support.

You can start a websocket connection in any _catacumba_ handler or route handler using `websocket`
function. It not need special handlers for treat websockets. Let see an example:

[source, clojure]
----
(defn my-websocket-echo-handler
  [{:keys [in out]}]
  (go-loop []
    (if-let [received (<! in)]
      (do
        (>! out received)
        (recur))
      (close! out))))

(defn my-handler
  [context]
  (ct/websocket context my-websocket-echo-handler))

(def route
  (ct/routes [[:prefix "events"
               [:any my-handler]]]))
----


Additionally, _catacumba_ offers a a way to setup websocket handler directly, without additional step
on default handler:

[source, clojure]
----
(defn echo-handler
  "This is my echo handler that serves as
  a websocket handler example."
  {:handler-type :catacumba/websocket}
  [{:keys [in out]}]
  (go-loop []
    (if-let [received (<! in)]
      (do
        (>! out received)
        (recur))
      (close! out))))

(def route
  (ct/routes [[:prefix "events"
               [:any #'echo-handler]]]))
----

As you can observe, a function has additional metadata that indicates to _catacumba_ that that
function is a websocket type handler, so _catacumba_ bootstraps the websocket connection for you.

Is very important pass a var reference to the router instead of the function directly, because
the metadata defined in the function is bound to the var and not to the function.

Also, you can attach metadata inline, using the `with-meta` clojure builtin function:

[source, clojure]
----
(ct/routes [[:prefix "events"
             [:any (with-meta echo-handler
                     {:handler-type :catacumba/websocket})]]])
----

Clojure offers a lot of flexibility for work with metadata so, you can set the handler type
in the way that you prefers.


=== Server-Sent Events

WebSockets are cool because they allow bi-directional comunication, but in some circumstances we only
need something unidirectional, for notify the client about some changes or any other events. For this
purpose exists link:https://developer.mozilla.org/en-US/docs/Server-sent_events[Server-Sent Events]
and _catacumba_ also has support for it.

The handlers for sse not differs a lot from websockets that we have seen in previous section. The
main difference is that the reception of the data is not allowed.

[source, clojure]
----
(defn time-notification
  "Handler that notifies each second
  the current server time to the client."
  {:handler-type :catacumba/sse}
  [context out]
  (go-loop []
    (when-let [_ (>! out (str (java.time.Instant/now)))]
      (<! (timeout 1000))
      (recur))))

(def route
  (ct/routes [[:prefix "events"
               [:any #'time-notification]]]))

----

In a similar way to websockets, you can start the sse in any place, such as standard _catacumba_ handler:

[source, clojure]
----
(defn time-notification
  "Handler that notifies each second
  the current server time to the client."
  [context]
  (ct/sse context
          (fn [_ out]
            (go-loop []
              (when-let [_ (>! out (str (java.time.Instant/now)))]
                (<! (timeout 1000))
                (recur))))))

(def route
  (ct/routes [[:prefix "events"
               [:any time-notification]]]))

----

Let see some examples how you can send other parameters that simple data:

[source, clojure]
----
;; Send data
(>! out "data as string")
(>! out {:data "data as string"})

;; Send data with event name
(>! out {:data "data as string" :event "foobar"})

;; Set id
(>! out {:id "2"})
----

NOTE: The _catacumba_'s sse support uses core.async channels, but if you are not
happy with core.async and want use something different (such as manifold streams), you may want know
that everything in _catacumba_ is implemented using abstractions and to implement your own sse type
of handler that uses manifold streams is very easy.


=== Ring compatibility

Although ring support is not first citizen in _catacumba_, the current design of it allows create an
handler adapter that follows the ring specification. This is a great example of extensibility of
_catacumba_.

Let see how it can be done:

[source, clojure]
----
(defn myringhandler
  "My example ring handler."
  {:handler-type :catacumba/ring}
  [request]
  {:status 200
   :body "hello world"})

;; As standalone handler
(ct/run-server #'myringhandler)

;; Or in a _catacumba_ routing chain
(-> (ct/routes [[:get #'myringhandler]])
    (ct/run-server))
----

Ring handlers can be set as standalone handlers (mainly for use them as compojure and all related
middlewares) or in a _catacumba_'s routing chain.


== Builtin Handlers

This section will cover different kind of builtin additional handlers for make the experience of
using _catacumba_ more pleasant.


=== Body parsing

_Catacumba_ comes with builtin support for conditional body parsing depengin on the incoming
content type. It consists in a route chain that adds the `:body` entry in the context with the
parsed data or `nil` in case of incoming content type does not has attached parser implementation.

For use it, it is simple as prepend the `body-params` handler to your route chain:

[source, clojure]
----
(require '[catacumba.handlers :as hs])

(defn example-handler
  [context]
  (let [body (:body context)]
    (println "Received body:" body) 
    (http/no-content)))

(def app
  (ct/routes [[:any (hs/body-params)]
              [:any example-handler]]))

;; ...
----

By default, the `application/x-www-form-urlencoded`, `multipart/form-data` and
`application/json` parsers are comes out of the box.
The link:https://github.com/dakrone/cheshire[cheshire] json parser is used
for parse body with the `application/json` content type.

The body parsing is a open system, implemented using clojure polymorphism facilites
such as multimethods. If you want add additional parser, is as simple how add
implmenetation to the `parse` multimethod with your content-type as dispatch tag.

[source, clojure]
----
(require '[catacumba.handlers.parsing :as parsing])
(import 'ratpack.http.TypedData
        'ratpack.handling.Context)

(defmethod parsing/parse :application/xml
  [^Context ctx ^TypedData body]
  ;; your parsing logic here
  )
----


=== Auth

The authentication facilites in _catacumba_ are built using link:https://github.com/funcool/buddy[buddy]
security library.

As _catacumba_ handlers system is very flexible, you really don't locked to use _buddy_. You can
write your own auth facilities and attach them to _catacumba_ using the routing chain.

For start using auth facilities in your application, you should add the `auth` handler
to you routing chain. Let see an example using session based auth backend:

[source, clojure]
----
(require '[catacumba.handlers :as hs])
(require '[catacumba.handlers.auth :as auth])

;; Create an instance of auth backend
(def auth-backend
  (auth/session-backend))

(def app
  (ct/routes [[:any (hs/session {:storage :inmemory})]
              [:any (hs/auth auth-backend)]
              [:get some-handler]]))
----

As we mentioned previously, behind the scenes _buddy_ is used, so almost all auth backends
defined in buddy can be used with _catacumba_, such as jws and jwe backens.

It there some exceptions, such as the session auth backend, because the sessions works
slightly different in _catacumba_ and the buddy session auth backend reliad in a ring
session behavior.

The buddy access rules are not supported because, the _catacumba_ routing chain system
fullfills that gap. You can define concrete authorization rules and attach them directly
in a routing chain.

You can see a working example using auth facilties <<website-example,here>>.


=== Sessions

==== Getting Started

The http sessions in _catacumba_ are also implemented as chain handler. So, you can add sessions
to you application just adding the handler to your routing chain:

[source, clojure]
----
(require '[catacumba.handlers :as hs])

(def app
  (ct/routes [[:any (hs/session {:storage :inmemory})]
              [:get your-handler]]))
----

All handlers in the route pipeline that are going after the session handler will come with `:session`
key in the context with a "atom" like object. You just treat it as atom, so for attach some data
to the session you should use the well known `swap!` function:

[source, clojure]
----
(defn my-handler
  [context]
  (let [session (:session context)]
    (swap! session assoc :userid 1)
    "my response"))
----

You can clean the session just reseting to the empty map:

[source, clojure]
----
(reset! session {})
----

One of the big advantages of using the chain routing for setup session, is that you put session
to a concrete subset of urls/resources avoiding unnecesary code execution for hendler that
does not need sessions:

[source, clojure]
----
(def app
  (ct/routes [[:prefix "admin"
               [:any (hs/session {:storage :inmemory})]
               [:get your-handler]]
              [:prefix "api"
               [:get "users" other-handler]
               [:get ...]]]))
----


==== Session storages

Currently _catacumba_ comes with one basic session storage, the `:inmemory`. But the session
storage system is plugable and is defined in terms of the following protocol:

[source, clojure]
----
(defprotocol ISessionStorage
  (read-session [_ key])
  (write-session [_ key data])
  (delete-session [_ key]))
----

If you known the ring based session storages, you can observe that the _catacumba_ session
storage abstraction is almost identical to the ring session abstracition, so migrate or
adapt the ring session storages is really easy.

For use a concrete session storage, just pass a instance of it as value of the `:storage`
key in a session handler constructor:

[source, clojure]
----
(hs/session {:storage (my-storage-constructor)})
----


=== Context as Request

By default, the _catacumba_'s context allows you direct access to the request and response, that are
instances of classes defined in Ratpack. That classes allows you access to all related properties
such as headers, the request body, the request method, etc.

But _catacumba_ at this moment offers a very limited set of helper functions for interacting with that
data: get/set headers and read the body (explained in previous sections).

For compensate this, _catacumba_ comes with special chain handler that populates the context with
basic request properties such as, headers, path and method:

[source, clojure]
----
(require '[catacumba.handlers :refer [basic-request]])

(def app
  (ct/routes [[:prefix "api/v1"
               [:any basic-request]
               [:get "foo" some-handler]
               [:post "foo" some-save-handler]]]))
----


=== Security

==== Cross-Origin Resource Sharing

Is a mechanism that allows restricted resources (e.g. fonts, JavaScript, etc.) on a web page to be
requested from another domain outside the domain from which the resource originated.

Is often used for protect api resources to be accessed out of the domain of your web applications.

_Catacumba_ has builtin support for CORS, let see how you can use it:

[source, clojure]
----
(require '[catacumba.handlers :refer [cors]])

(def cors-conf {:origin #{"http://website.com"}                       ;; mandatory
                :max-age 3600                                         ;; optional
                :allow-headers ["X-Requested-With", "Content-Type"]}) ;; optional

(def app
  (ct/routes [[:prefix "api/v1"
               [:any (cors cors-conf)]
               [:get "foo" some-handler]
               [:post "foo" some-save-handler]]]))
----

The `:origin` key can be a set of possible origins or directlly `"*"` for allow all origins.


==== Content Security Policy

Is a security related chain handler that appropiatelly set the `Content-Security-Policy` headers.

Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain
types of attacks, including Cross Site Scripting (XSS) and data injection attacks. These attacks are
used for everything from data theft to site defacement or distribution of malware.

Here a simple example on how to use it:

[source, clojure]
----
(def cspconf {:default-src "'self' *.trusted.com"
              :img-src "*"
              :frame-ancestors "'none'"
              :reflected-xss "filter"})

(def app
  (ct/routes [[:prefix "web"
               [:any (csp-headers cspconf)]
               [:get your-handler]]])
----

You can read more about that here: https://developer.mozilla.org/en-US/docs/Web/Security/CSP. The
complete list of directives can be found here: https://developer.mozilla.org/en-US/docs/Web/Security/CSP/CSP_policy_directives

This handler supports the following directives: `:default-src`, `:frame-ancestors`, `:frame-src`,
`:child-src`, `:connect-src`, `:font-src`, `:form-action`, `:img-src`, `:media-src`,  `:object-src`,
and `:reflected-xss`.


==== Frame Options

This is a security related chain handler that adds `X-Frame-Options` header to the response.

The X-Frame-Options HTTP response header can be used to indicate whether or not a browser should
be allowed to render a page in a `<frame>`, `<iframe>` or `<object>` . Sites can use this to avoid
clickjacking attacks, by ensuring that their content is not embedded into other sites.

Example:

[source, clojure]
----
(require '[catacumba.handlers :as handlers])

(def app
  (ct/routes [[:prefix "web"
               [:any (handlers/frame-options-headers {:policy :deny})]
               [:get your-handler]]]))
----

The possible values for the `:policy` key are: `:deny` and `:sameorigin`.

WARNING: The frame-ancestors directive from the CSP Level 2 specification
officially replaces this non-standard header.


==== Strict Transport Security

This is a security related chain handler that adds the `Strict-Transport-Security` to the response.

HTTP Strict Transport Security (often abbreviated as HSTS) is a security feature that lets a web
site tell browsers that it should only be communicated with using HTTPS, instead of using HTTP.

Usage example:

[source, clojure]
----
(require '[catacumba.handlers :as handlers])

(def app
  (ct/routes [[:prefix "web"
               [:any (handlers/hsts-headers {:max-age 31536000 :subdomains true })]
               [:get your-handler]]]))
----

You can read more about that headers here: https://developer.mozilla.org/en-US/docs/Web/Security/HTTP_strict_transport_security


==== Content Type Options

This is a security related chain handler that adds the `X-Content-Type-Options` header to the
response.It prevents resources with invalid media types being loaded as stylesheets or scripts.

This chain handler does not have any additional parameter. Let see an example on how you
can use it:

[source, clojure]
----
(require '[catacumba.handlers :as handlers])

(def app
  (ct/routes [[:prefix "web"
               [:any handlers/content-type-options-headers]
               [:get your-handler]]]))
----


More information:

* http://msdn.microsoft.com/en-us/library/ie/gg622941(v=vs.85).aspx
* https://www.owasp.org/index.php/List_of_useful_HTTP_headers


== Advanced topics

=== Modular components

_Catacumba_ is build from its ground with optional support for the `stuartsierra/component`, and
exposes a `catacumba-server` component with api for add routes and handlers from other components.

Let see a little example on how it can be used:

[source, clojure]
----
(ns yourapp.system
  (:require [com.stuartsierra.component :as component]
            [catacumba.components :refer (catacumba-server assoc-routes!)]))

;; Define your web application component, it will be responsable to setup
;; the routes to the catacumba-server component of your handlers

(defrecord WebApp [server]
  component/Lifecycle
  (start [this]
    (let [routes [[:get "foo" some-handler]
                  [:get "bar" other-handler]]
      (assoc-routes! server ::web routes)))

  (stop [this]
    ;; noop
    ))

;; Define a simple constructor for your web application component
(defn webapp []
  (->WebApp nil))

;; Define the system with two main components: catacumba-server and webapp
;; and explicitly specify the dependency of catacumba-server for webapp/

(defn application-system
  "The application system constructor."
  []
  (-> (component/system-map
       :catacumba (catacumba-server {:port 5050})
       :app (webapp))
      (component/system-using
       {:app {:server :catacumba}})))

;; Just define a entry point for the application.

(defn -main
  "The main entry point to your application."
  [& args]
  (component/start (application-system)))
----

Take care, each call to the `assoc-routes!` function, the server is reloaded. In the majority of
circumstances this is completely irelevant because it is done in a application bootstrap time.

For understand it better, _catacumba_ comes with an <<sse-component-example,example>> that builds a
multiuser char using "Server-Sent events" and component, so you can experiment with real code.
See the <<examples,examples>> section for it.


=== Launching the server

As you can see in the quick start section, the main entry point for start the server is
the `run-server` function that receives a handler and a map with options.

At this moment, it has a very little subset of options that netty and ratpack offers but is good
start point.

.Supported options
[options="header", cols="^1,^1,^2"]
|===========================================================================
| Keyword   | Default | Description
| `:port`   | `5050` | The port to listen on.
| `:threads` | (num of cores * 2) | The number of threads for handler requests.
| `:debug` | `true` | Start in development mode.
| `:setup` | nil    | A callback for configuration step (low level ratpack access).
| `:basedir` | nil | The application base directory, used mainly for resolve relative paths and assets.
|===========================================================================

All supported options of this function, can be overwritten on jvm startup, using environment variables
or system properties. This allows customize the server out of source code and exists for convenience
for make easy customizations in deployments.

For example, you can change the default port on jvm startup using `CATACUMBA_PORT` environment variable
or `catacumba.port` system property:

.Example using enviroment variables
[source, bash]
----
export CATACUMBA_PORT=8000
export CATACUMBA_BASEDIR=`pwd`
java -jar yourjarhere.jar
----

.Example using enviroment variables
[source, bash]
----
java -Dcatacumba.port=8000 -Dcatacumba.debug=false -jar yourjarhere.jar
----


[[examples]]
== Examples

[[website-example]]
=== Website and Auth

This example tries to show the way to use _catacumba_ in a website like projects, with authentication
and session.

You can see the example code here:
https://github.com/funcool/catacumba/tree/master/examples/website


[[single-file-example]]
=== Single file web app

This example tries to show hoy you can use _catacumba_ for build small web applications that fits
in one file and execute them like a shell script or an executable.

This example requires http://boot-clj.com/

https://github.com/funcool/catacumba/tree/master/examples/single-file


[[sse-component-example]]
=== Multiuser chat with SSE

This example tries to demostrate how can you build a simple chat using "Server-Sent Events" for
communicating events to the client and using *stuartsierra/component* for the modular application
architecture.

You can see the example code here:
https://github.com/funcool/catacumba/tree/master/examples/component-chat


=== Debugging with prone

link:https://github.com/magnars/prone[Prone] is really awesome middleware for ring that shows
a beautiful and human readable stack traces when a exception is raised in our application. It is not
directly compatible with _catacumba_ but is relativelly easy adapt it.

You can see the example code here: https://github.com/funcool/catacumba/tree/master/examples/debugging

NOTE: Obviously, if you are using the ring type of handler, you can use prone as is, without any
additional adaptation. This example shows how it can be used with default handler type.


=== Instrumentation

_Catacumba_ comes with the ability to instrument your application for take different kind of diagnosis,
such as performance, latency, etc. This example shows how it can be done.

You can see the example code here: https://github.com/funcool/catacumba/tree/master/examples/interceptor



== FAQ

[[difference-with-aleph]]
=== Differences with aleph

First of all, Aleph is one of the most robust libraries in clojure ecosystem for building asynchronous
servers. Here is an incomplete list of differences and motivations why I wrote _catacumba_ instead
of using _aleph_ directly in my applications:

- Aleph with manifold offers good abstractions for creating async servers but they are to much
  low level and only provide the basic building blocks. _catacumba_ intends to be a toolkit highly
  focused on web development providing a good collection of facilities for that.
- I wrote _catacumba_ tp have something different to ring and _Aleph_ that uses ring abstraction for
  handle web requests.
- Aleph has a good path to have an easily readable  and user friendly documentation.
- Aleph is build on manifold streams and _catacumba_ uses reactive-streams abstractions.

_Catacumba_ does not intend to be a replacement for it, it simply has different focus.


== Developers Guide

=== Philosophy

Five most important rules:

- Beautiful is better than ugly.
- Explicit is better than implicit.
- Simple is better than complex.
- Complex is better than complicated.
- Readability counts.

All contributions to _catacumba_ should keep these important rules in mind.


=== Contributing

**catacumba** unlike Clojure and other Clojure contrib libs, does not have many
restrictions for contributions. Just open a issue or pull request.


=== Source Code

_catacumba_ is open source and can be found on link:https://github.com/funcool/catacumba[github].

You can clone the public repository with this command:

[source,text]
----
git clone https://github.com/funcool/catacumba
----


=== Run tests

For run tests just execute this:

[source, text]
----
boot watch-tests
----


=== License

_catacumba_ is licensed under BSD (2-Clause) license:

----
Copyright (c) 2015, Andrey Antukh <niwi@niwi.be>

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
----
