= Catacumba - Web toolkit for Clojure.
Andrey Antukh, <niwi@niwi.be>
:toc: left
:!numbered:
:idseparator: -
:idprefix:
:source-highlighter: pygments
:pygments-style: friendly
:sectlinks:


== Introduction

_Catacumba_ is an asynchronous and non-blocking web toolkit for Clojure built on top of
ratpack and netty. Is highly inspired by ratpack handlers approach with a little ideas from the
well known ring.


=== Rationale

I start writting this library as a research project to provide a simple an non obstructive
(a la ring) way to build asynchronous and non-blocking web services.

In the Clojure ecosystem there are several solutions for that purpose: Pedestal, Aleph, and Jet.
All them are good Clojure libraries/frameworks but none of them satisfies me for different reasons:

* The pedestal approach is very opinionated and too much high level and I prefer something simple,
  lightweight and maybe less opinionated.
* Aleph, seems like a great library but lacks good, readable, user friendly documentation and
  its generic approach (not only http) does not help much. If you want read more about differences with
  aleph, see <<difference-with-aleph,this>> faq entry.
* Jet is a asynchronous ring addapter for Jetty 9. It is really great library that I have used in
  some projects, and fits very well on my idea of web toolkit but it has two drawbacks, it is build
  as ring adapter having all the good and all the bad of ring and it is using Jetty (Jetty is a
  servlet server that comes with optional async support, it isn't asynchronous from the ground up).


=== Goals

Here a incomplete list of things that _catacumba_ aims to achieve:

* Have a flexible and extensible way to setup different kind of handlers
* Provide a simple and lightweight approach for defining asynchronous web services with support for
  different abstractions, such as promises, futures, core.async, manifold, reactive-streams, ...
* Build almost everything up on abstractions for simple and easy extensibility.
* Provide a built-in, data-based routing.
* To be flexible and not very opinionated.
* Have backpressure support out of the box.

_Catacumba_ goals are not:

* To be a fully integrated full stack solution like immutant or pedestal.
* To provide an opinionated way to structure your "bussines logic"
* To provide all possible features that you might need.
* To be a low level, ring based library.


=== Project Maturity

Since _catacumba_ is a young project there can be some API breakage.


=== Requirements

_Catacumba_ is only runs with *JDK8* and *Clojure 1.7+* (due to extensive use of transducers
and jdk8 concurrency primitives).


=== Install

This section covers the _catacumba_ library installing process and its requirements.

*Leiningen*

The simplest way to use _catacumba_ in a clojure project, is by including it in the dependency
vector on your *_project.clj_* file:

[source,clojure]
----
[funcool/catacumba "0.2.0"]
----

*Gradle*

If you are using gradle, this is a dependency line for gradle dsl:

[source, groovy]
----
compile "funcool:catacumba:0.2.0"
----

[[quickstart]]
== Quick Start

This section intends to explain how to get _catacumba_ up and running.


=== First handler

The handler consists of a function that accepts a "context" as first parameter and
returns something renderable. Let see an example:

[source, clojure]
----
(defn my-hello-world-handler
  [context]
  "Hello World")
----

The handler may look very familiar if you have used ring previously. The main difference
is that it receives a context object instead of a request object. Additionally it may return a string directly.

The following sections explain all related concepts and give a full introduction on how handlers work.


=== Running the server

Now having defined the simple, hello world handler, it is time to run it. To do it,
import the `run-server` function from `catacumba.core` ns and execute it with
handler as first parameter:

[source, clojure]
----
(require '[catacumba.core :as ct])

(ct/run-server my-hello-world-handler)
----

TIP: The `run-server` function does not block and you can execute it in a repl without
problems. It uses jvm not daemon threads for avoid shutdown the jvm.


=== Complete example

This is what the complete source code of the example looks like:

[source, clojure]
----
(ns exampleapp.core
  (:require [catacumba.core :as ct])
  (:gen-class))

(defn my-hello-world-handler
  [context]
  "Hello World")

(defn -main
  [& args]
  (ct/run-server my-hello-world-handler))
----


_Catacumba_ comes with a little collection of <<examples,Examples>> that may help
you setup your first project.


== User Guide

This section intends explain all the different parts of _catacumba_ and
how they are playing together.


=== Handlers

The idea of handlers is a fundamental piece of the _catacumba_ library and this chapter intends
to explain everything related to default handlers.


==== What is a handler?

As we have seen int the "<<Quick Start,quickstart>>" section, a handler mainly consists of a simple function
that acts on the handling context.

Do not worry about the context for now, it will be explained in later sections. The only thing that you
should known about it at this time, is that is the central part of the request and response
lifetime. It stores the current state of the http request and everything related.

The hello world handler has this source code:

[source, clojure]
----
(defn myhandler
  [context]
  "Hello World")
----

NOTE: I mention the "default" word because, _catacumba_ comes with different types of
handlers out of the box and allows to be extended with used defined ones.


==== Write to response

As you can observe from the previous example, no status code is being provided, only the body of the response. To
send a complete response you can use a builtin response type or a ring-like hashmap:

[source, clojure]
----
(require '[catacumba.http :as http])

(defn my-handler
  [context]
  (http/ok "Hello World"))
----

Following output data types are supported for a handler function:

- a *string*, will result in a response with status code 200 and "text/plain" as content type.
- a *ring style* hash map.
- a *response* type (very similar to ring one).

The handler's return value is implemented using clojure protocols and its behavior can be extended
easily with user defined types.

Let see an other example, using _catacumba_'s response type with additional header:

[source, clojure]
----
(require '[catacumba.http :as http])

(defn myhandler
  [context]
  (http/ok "<p>Hello World</p>" {:content-type "text/html"}))
----

In the previous examples, we have seen how the return value is handled, but behind the scenes
the context is the responsible of interactions with the request and the response. Let see the
same example but interacti directly with the context:

[source, clojure]
----
(def myhandler
  [context]
  (ct/set-status! context 200)
  (ct/set-headers! context {:content-type "text/plain"})
  (ct/send! context "hello world"))
----

The return value handling is really a helper for people coming from ring. Internally, the
context is the main protagonist in IO operations.


==== Reading the request

As we mentioned previously, the request can also be retrieved from the context instance. But in our case,
_catacumba_ provides helpers functions to access the most essential data such as the request body, request
headers, cookies and routing tokens.

You can access to the request object using the `get-request` function. But, in almost all situations you
do not need it because the _catacumba_ api is polymorphic and you can get access to almost all basic
properties from request using a context as parameter, so you don't need to extract the request from context repeatedly.


===== Body

For access to the request body, _catacumba_ exposes a `get-body` function. This function returns a
ratpack link:http://ratpack.io/manual/current/api/ratpack/http/TypedData.html[internal type] that
represents a body.

That object exposes through Java interop methods to access the content type and the raw data of the request body. For
convenience sake, it also implements the necesarry protocols of the `clojure.java.io` namespace to make it
compatible with Clojure's native facilities for reading data.

A good demostration of this is using the clojure `slurp` function. It uses `clojure.java.io` abstractions
behind the scenes and serves as helper for reading a resource as a string:

[source, clojure]
----
(def myechohandler
  [context]
  (let [^String body (slurp (ct/get-body context))]
    (http/ok body)))
----

If you don't know the behavior of slurp, it reads the content of the provided resource as string
and return it.

Furthermore, _catacumba_ offers a more flexible way to parsing body data based on the incoming
content type, but it is explained with more details in the <<Body parsing section,body-parsing>> of this document.


===== Headers

In order to extract headers you should use the `get-headers` function. As usual, it is a polymorphic function
and you could use it with a context instance without problems. The return value is a clojure map.

If a header has multiple values, the value will be a vector.

[source, clojure]
----
(ct/get-headers context)
;; => {:content-type ...}
----


===== Cookies

The cookies CRUD operations works very similiar to the headers one. It consists in two polymorphic
functions (`get-cookies` and `set-cookies!`) that can be used directly with context or with request
or response instances.

.Get cookies from request example
[source, clojure]
----
(ct/get-cookies context)
;; => {:cookiename {:value "value" :path "/" :secure false}}
----

.Set cookies in the response
[source, clojure]
----
(ct/set-cookies context {:cookiename {:value "foobar" :max-age 3600}})
----

The cookies map is almost identical to the one that you can find in ring, and has the following possible
properties:

* `:domain` - restrict the cookie to a specific domain
* `:path` - restrict the cookie to a specific path
* `:secure` - restrict the cookie to HTTPS URLs if true
* `:http-only` - restrict the cookie to HTTP if true
                 (not accessible via e.g. JavaScript)
* `:max-age` - the number of seconds until the cookie expires


=== Routing

In contrast to ring, _catacumba_ is a toolkit for web development and offers builtin support for
advanced routing that allows handlers chaining, partitioning, error handling, among other features.

NOTE: _Catacumba_ has a polymorphic and extensible way to setup handlers, and routing is one of multiple possible
implementations. Is completely optional and you can use any other routing library if you want.


==== Basic syntax

The routes in _catacumba_ are defined using clojure data structures: vectors and keywords. Let's
see a little example of the aspect in a complete example:

[source, clojure]
----
(def routes
  (ct/routes [[:prefix "api"
               [:get "users" users-handler]]]))

(ct/run-server routes)
----

The order of statements is very important because the routing in _catacumba_ is a simple chain or pipeline.
Each handler has the ability to delegate the request handling to the next handler in the pipeline.

This is a complete list of route directives that you can use a part of `:get`:  `:any` (matches all
routes, often used for add chain handlers), `:post`, `:put`, `:patch` and `:delete`.


==== Dispatch by method

In some circumstances you may want have different handlers depending on the HTTP method used
for one concrete endpoint. For this purpose there is the `:by-method` route directive:

[source, clojure]
----
(ct/routes [:prefix "api"
            [:by-method "users"
             [:get list-users-handler]
             [:post create-users-handler]]])
----


==== Routing params

_catacumba_'s routing also allows to capture URL values encoded in the URL or as URL parameters using special symbols.
For example, the path string "foo/:val" will match paths such as "foo/bar", "foo/123".  The matched parameters
are automatically populated to the context under the `:route-params` keys.

[source, clojure]
----
(def article-detail
  [context]
  (let [id (get-in context [:route-params :id])]
    (http/ok (str "You have requested article with id=" id))))

(def app
  (ct/routes [[:get "articles/:id" article-detail]]))
----

Additionally to the basic token for representing URL parameters, _catacumba_ also allows the use of
regular expressions for delimiting the input or marking a URL token optional.

See the following table for all supported URL tokens:

.Supported url matching tokens
[options="header", cols="2,3,3,2"]
|===========================================================================
| Path Type | Syntax | Route example | Matching url example
| Literal | `foo` | `[:get "foo" handler]` | `/foo`
| Mandatory | `:«token-name»` | `[:get "foo/:param" handler]` | `/foo/bar`
| Optional | `:«token-name»?` | `[:get "foo/:param?" handler]` | `/foo` and `/foo/bar`
| Mandatory & Regex | `:«token-name»:«regex»` | `[:get "foo/:id:\d+" handler]` | `/foo/2`
| Optional & Regex | `:«token-name»?:«regex»` | `[:get "foo/:id?:\d+" handler]` | `/foo/2` and `/foo`
|===========================================================================


==== Routing chain

The chaining of handlers can be done in two different ways:

- *inline*: providing more that one handler for concrete http method.
- *multiple routes*: providing a "match all" handler at the start of prefix.

Chaining handlers inline follows this pattern:

[source, clojure]
----
(ct/routes [[:get "users" permission-check-handler get-users-handler]])
----

Additionally, you can setup "catch all" handlers at the start of a routing
definition and use them as interceptors:

[source, clojure]
----
(def routes
  (ct/routes [[:prefix "api"
               [:any authentication-handler]
               [:get "users" users-handler]]]))
----

For a better understanding of how the handler delegation chain works, see the *Context* chapter.


==== Error handling

The _catacumba_ router chain allows to setup user defined error handling
functions. This requires a very, very simple setup, you only have to add another
route entry with using `:error` route directive:

[source, clojure]
----
(def routes
  (ct/routes [[:error my-error-handler]
              [:get "users" users-handler]]))
----

With the previous code we have set up a global error handler, applying to all
routes in the chain. But there is also the possibility to set different error
handlers for different prefixes:

[source, clojure]
----
(def routes
  (ct/routes [[:prefix "api"
               [:error my-error-handler-for-this-prefix]
               [:any authentication-handler]
               [:get "users" users-handler]
               [:put "users" check-permissions-handler update-users-hander]]
              [:prefix "admin"
               [:error my-error-handler-for-this-other-prefix]
               [:get "dashboard" my-dashboard-handler]]]))
----

The error handler signature is very similar to standard HTTP handler signature,
with the difference being that it receives the throwable instance as an
additional parameter:

[source, clojure]
----
(defn my-error-handler
  [context error]
  (http/internal-server-error (.getMessage error)))
----


=== Context

Another core part of _catacumba_ is the *Context*.

Just like in ratpack, the context in _catacumba_ has following responsbibilities:

* Provide direct access to the request and response objects.
* Access to the contextual objects (called registry).
* Flow control in handler chaining.
* Convenience helpers for common handlers operation.


==== Handler delegation

In _catacumba_, the request is handled using a chain of handlers. Each concrete
handler can decide to delegate some work to the next matching handler in the chain.
You have probably seen the different ways of chaining handlers in the router section,
in this section we will see how we can delegate the request
handling to the next matching handler.

The delegation action can be done with `delegate` multiarity function. Let see a simple example:

[source, clojure]
----
(defn handler1
  [context]
  (do-something context)
  (ct/delegate context))

(defn handler2
  [context]
  (http/ok "hello world"))

(def router
  (ct/routes [[:get "foo" handler1 handler2]]))
----

In this example, when the request arrives at `handler1`, it delegates the execution to the next
handler in the chain. It do not need to know about next handler, it just delegates to the routing chain
to find a next handler or raise a corresponding error.

In addition to the simple handler delegation, _catacumba_ offers a simple way to pass context data
to the next handler in the chain. It can be done by passing an additional parameter to the `delegate` function:

[source, clojure]
----
(defn handler1
  [context]
  (do-something context)
  (ct/delegate context {:message "foobar"}))

(defn handler2
  [context]
  (let [message (:message context)]
    (http/ok message)))
----

In the example above, the second handler prints the message found in the context.


== Handler types

This section intends to explain the different kind of builting handler types.

=== Asynchronous

Asynchronous handlers are handlers that return a value in an asynchronous way using one of the
supported abstractions, such as core.async, reactive-streams and many others (explained below).


==== Channels

The `core.async` channel is one of the supported abstractions that comes with _catacumba_ out
of the box. It consists of a handler that returns a body as a channel or response as a channel.

This is the aspect of async handler returning the channel as a body:

[source, clojure]
----
(defn my-async-handler
  [context]
  (let [ch (chan)]
    (go
      (dotimes [i 10]
        (<! (timeout 500))
        (>! ch (str i "\n")))
      (close! ch))
    (http/ok ch)))
----

Returning a channel as the body has the advantage that you have the ability of setting additional
headers and HTTP status in your function body code. But, if you are return a channel as a response
value, the default status code will be set for you. The behavior of two approaches is the same,
resulting in a chunked encoded response to the client.

And this is an example of an async handler returning a channel as response:

[source, clojure]
----
(defn my-async-handler
  [context]
  (go
    (let [result (<! (do-some-async-task))]
      (:message result)))
----

Do not worry about how much data you can send to the client, if you are using channels in a right way
(in a go block), you will send data to the client as fast as the client can consume it. This technique is
also called backpressure, and is fully supported for chunked responses.


==== Promises

Promises are another abstraction supported out of the box in _catacumba_. It comes from the
link:https://github.com/funcool/futura[futura library] and is build on top of JDK8 _CompletableFuture_.

Sometimes, you do not need send a chunked stream to the client, but your "bussines logic" is defined
in an asynchronous friendly API using promises (or something similar). In this case, with _catacumba_
you can return a promise as a body or as a response and the data will be sent to the client when
the promise has been resolved successfully.

[source, clojure]
----
(require '[futura.promise :as p])

(defn my-async-handler
  [context]
  (let [promise (p/promise "hello world")]
    (http/ok promise {:content-type "text/plain"})))
----

Thanks to the *futura* library internals, we can use it with
link:https://github.com/funcool/cats[cats] `mlet` macro, that allows us structure pure async
code in a synchronous way:

[source, clojure]
----
(require '[futura.promise :as p])
(require '[cats.core :as m])

(defn my-async-handler
  [context]
  (m/mlet [a (something-that-returns-promise context)
           b (do-something-with a)]
    (do-other-thing-with b)))
----

The result of `mlet` macro expression will be a *promise* with the eventually available result
from `(do-other-thing-with b)` expression.


==== Futures

As previously explained promises are built on top of *CompletableFutures* of JDK8, _catacumba_ also
supports the raw usage of them:

[source, clojure]
----
(defn my-async-handler
  [context]
  (-> (something-that-returns-completable-future context)
      (http/ok {:content-type "text/plain"})))
----


==== Manifold

The link:https://github.com/ztellman/manifold[manifold] library offers different kind of deferred and
stream abstractions for Clojure and you can use both them as response or body of the response for sending
data to the client asynchronously.

[source, clojure]
----
(require '[manifold.deferred :as d])

(defn my-async-handler
  [context]
  (let [result (d/future (Thread/sleep 1000) "hello world")]
    (http/ok result {"content-type" "text/plain"})))
----


==== Reactive Streams

This is the core of all abstractions, and support for it comes out of the box from *ratpack*. All
other abstractions that we have seen are always coerced to a *Publisher* instance before sending it to the
client.

Here there isn't anything  new to explain, if you have a function that return some kind of *Publisher*, you can return
it as response or send it as body like as usual.

The adaptations and coercions are done thanks to the
link:https://github.com/funcool/futura[futura library] that has more adaptations supported out of the
box that which are coming with _catacumba_.

Let see an example:

[source, clojure]
----
(require '[futura.stream :as stream])
(require '[cuerdas.core :as str])

(defn my-async-handler
  [context]
  (let [pub (->> (stream/publisher ["hello" " " "world"])
                 (stream/publisher (map str/upper)))]
    (http/ok pub)))

;; It will return a chunked response to the client with "HELLO WORLD" string.
----

The reactive streams implementation in the link:https://github.com/funcool/futura[futura library] comes with
support for different kind of coercions and with clojure 1.7 *transducers*.


=== Websockets

One of the main goals of _catacumba_ is come with builtin, full featured and backpressure-aware
websockets support.

You can start a websocket connection in any _catacumba_ handler or route handler using `websocket`
function. It does not require any special handlers for dealing with websockets. Let see an example:

[source, clojure]
----
(defn my-websocket-echo-handler
  [{:keys [in out]}]
  (go-loop []
    (if-let [received (<! in)]
      (do
        (>! out received)
        (recur))
      (close! out))))

(defn my-handler
  [context]
  (ct/websocket context my-websocket-echo-handler))

(def route
  (ct/routes [[:prefix "events"
               [:any my-handler]]]))
----


Additionally, _catacumba_ offers a a way to set up a websocket handler directly, without an additional step
in the default handler:

[source, clojure]
----
(defn echo-handler
  "This is my echo handler that serves as
  a websocket handler example."
  {:handler-type :catacumba/websocket}
  [{:keys [in out]}]
  (go-loop []
    (if-let [received (<! in)]
      (do
        (>! out received)
        (recur))
      (close! out))))

(def route
  (ct/routes [[:prefix "events"
               [:any #'echo-handler]]]))
----

As you can observe, for any function has additional metadata that indicates to _catacumba_ that this
function is a websocket type handler, _catacumba_ will bootstrap the websocket connection for you.

Is very important pass a var reference to the router instead of the function directly, because
the metadata defined in the function is bound to the var and not to the function.

Also, you can attach metadata inline, using the `with-meta` Clojure built-in function:

[source, clojure]
----
(ct/routes [[:prefix "events"
             [:any (with-meta echo-handler
                     {:handler-type :catacumba/websocket})]]])
----

Clojure offers a lot of flexibility for working with metadata so you can set the handler type
in the way that you prefer.


=== SSE (Server-Sent Events)

WebSockets are cool because they allow bi-directional comunication, but in some circumstances we only
need something unidirectional, for notifying the client about some changes or any other events. For this
purpose exists link:https://developer.mozilla.org/en-US/docs/Server-sent_events[Server-Sent Events] (SSE)
and _catacumba_ also has support for it.

The handler for SSE does not differs a lot from websockets that we have seen in the previous section. The
main difference is that the reception of the data is not allowed.

[source, clojure]
----
(defn time-notification
  "Handler that notifies each second
  the current server time to the client."
  {:handler-type :catacumba/sse}
  [context out]
  (go-loop []
    (when-let [_ (>! out (str (java.time.Instant/now)))]
      (<! (timeout 1000))
      (recur))))

(def route
  (ct/routes [[:prefix "events"
               [:any #'time-notification]]]))

----

In a similar way to websockets, you can start SSE in any place, such as a standard _catacumba_ handler:

[source, clojure]
----
(defn time-notification
  "Handler that notifies each second
  the current server time to the client."
  [context]
  (ct/sse context
          (fn [_ out]
            (go-loop []
              (when-let [_ (>! out (str (java.time.Instant/now)))]
                (<! (timeout 1000))
                (recur))))))

(def route
  (ct/routes [[:prefix "events"
               [:any time-notification]]]))

----

Let see some examples how you can send other parameters than simple data:

[source, clojure]
----
;; Send data
(>! out "data as string")
(>! out {:data "data as string"})

;; Send data with event name
(>! out {:data "data as string" :event "foobar"})

;; Set id
(>! out {:id "2"})
----

NOTE: The _catacumba_'s SSE support uses core.async channels, but if you are not
happy with core.async and want use something different (such as manifold streams), you may want know
that everything in _catacumba_ is implemented using abstractions and to implement your own SSE type
of handler that uses manifold streams is very easy.


=== Ring (Compatibility layer)

Although ring support is not first citizen in _catacumba_, the current design of it allows to create an
handler adapter that follows the ring specification. This is a great example of extensibility of
_catacumba_.

Let see how it can be done:

[source, clojure]
----
(defn myringhandler
  "My example ring handler."
  {:handler-type :catacumba/ring}
  [request]
  {:status 200
   :body "hello world"})

;; As standalone handler
(ct/run-server #'myringhandler)

;; Or in a _catacumba_ routing chain
(-> (ct/routes [[:get #'myringhandler]])
    (ct/run-server))
----

Ring handlers can be set as standalone handlers (mainly for using them with compojure and all related
middlewares) or in a _catacumba_'s routing chain.


=== CPS (Continuation-passing style)

TBD


== Built-in Handlers

This section will cover different kind of built-in additional handlers to make the experience of
using _catacumba_ more pleasant.


[[body-parsing]]
=== Body parsing

_Catacumba_ comes with builtin support for conditional body parsing depending on the incoming
content type. It consists of a routing chain that adds the `:body` entry in the context with the
parsed data or `nil` in case of an incoming content type does not have an attached parser implementation.

In order to use it, it is simple as prepending the `body-params` handler to your route chain:

[source, clojure]
----
(require '[catacumba.handlers :as hs])

(defn example-handler
  [context]
  (let [body (:body context)]
    (println "Received body:" body)
    (http/no-content)))

(def app
  (ct/routes [[:any (hs/body-params)]
              [:any example-handler]]))

;; ...
----

By default, the `application/x-www-form-urlencoded`, `multipart/form-data` and
`application/json` parsers come out of the box.
The link:https://github.com/dakrone/cheshire[cheshire] json parser is used
for parsing the body with the `application/json` content type.

The body parsing is a open system, implemented using clojure's polymorphism facilites
such as multimethods. If you want add additional parser, is as simple as adding an
implementation to the `parse` multimethod with your content-type as dispatch tag.

[source, clojure]
----
(require '[catacumba.handlers.parsing :as parsing])
(import 'ratpack.http.TypedData
        'ratpack.handling.Context)

(defmethod parsing/parse :application/xml
  [^Context ctx ^TypedData body]
  ;; your parsing logic here
  )
----


=== Authentication

The authentication facilites in _catacumba_ are built using the link:https://github.com/funcool/buddy[buddy]
security library.

As _catacumba_'s handler system is very flexible, you really don't need to use _buddy_. You can
write your own auth facilities and attach them to _catacumba_ using the routing chain.

In order to start using auth facilities in your application, you should add the `auth` handler
to you routing chain. Let see an example of using session-based auth backend:

[source, clojure]
----
(require '[catacumba.handlers :as hs])
(require '[catacumba.handlers.auth :as auth])

;; Create an instance of auth backend
(def auth-backend
  (auth/session-backend))

(def app
  (ct/routes [[:any (hs/session {:storage :inmemory})]
              [:any (hs/auth auth-backend)]
              [:get some-handler]]))
----

As we mentioned previously, behind the scenes _buddy_ is used, so almost all auth backends
defined in buddy can be used with _catacumba_, such as JWS and JWE backens.

However there are some exceptions, such as the session auth backend, because sessions work
slightly different in _catacumba_ and the buddy session auth backend relied on a ring-like
session behavior.

The buddy access rules are not supported because, the _catacumba_ routing chain system
fullfills that gap. You can define concrete authorization rules and attach them directly
in a routing chain.

You can see a working example using auth facilities <<website-example,here>>.


=== Sessions

==== Getting Started

The HTTP sessions in _catacumba_ are also implemented as chain handler. So you can add session handling support
to you application just by adding the handler to your routing chain:

[source, clojure]
----
(require '[catacumba.handlers :as hs])

(def app
  (ct/routes [[:any (hs/session {:storage :inmemory})]
              [:get your-handler]]))
----

All handlers in the route pipeline that are going after the session handler will come with `:session`
key in the context with a "atom" like object. You just treat it as atom, so for attaching some data
to the session you should use the well known `swap!` function:

[source, clojure]
----
(defn my-handler
  [context]
  (let [session (:session context)]
    (swap! session assoc :userid 1)
    "my response"))
----

You can clean the session just reseting to the empty map:

[source, clojure]
----
(reset! session {})
----

One of the big advantages of using the routing chain for session set up, is that you can restrict session halding
to a concrete subset of urls/resources avoiding unnecesary code execution for handlers that
do not need sessions:

[source, clojure]
----
(def app
  (ct/routes [[:prefix "admin"
               [:any (hs/session {:storage :inmemory})]
               [:get your-handler]]
              [:prefix "api"
               [:get "users" other-handler]
               [:get ...]]]))
----


==== Session storages

Currently _catacumba_ comes with one basic session storage, the `:inmemory`. But the session
storage system is pluggable and is defined in terms of the following protocol:

[source, clojure]
----
(defprotocol ISessionStorage
  (read-session [_ key])
  (write-session [_ key data])
  (delete-session [_ key]))
----

If you are familiar with the ring based session storages, you can observe that the _catacumba_ session
storage abstraction is almost identical to the ring session abstraction, so migrating from or
adapting the ring session storages is really easy. The unique difference is that functions
should return a promise (from futura library).

To use a concrete session storage, just pass a instance of it as value of the `:storage`
key in a session handler constructor:

[source, clojure]
----
(hs/session {:storage (my-storage-constructor)})
----

If you want implement own session storage, take a look to the `:inmemory` builtin one.


=== Context as Request

By default, the _catacumba_'s context allows you direct access to the request and response, both which are
instances of classes defined in Ratpack. These classes allows you to access all related properties
such as headers, the request body, the request method, etc.

But _catacumba_ additionally offers a small set of helper functions for interacting with that
data: getting/setting headers and reading the body (explained in previous sections).

To compensate for this, _catacumba_ comes with a special chain handler that populates the context with
basic request properties such as, headers, path and method:

[source, clojure]
----
(require '[catacumba.handlers :refer [basic-request]])

(def app
  (ct/routes [[:prefix "api/v1"
               [:any basic-request]
               [:get "foo" some-handler]
               [:post "foo" some-save-handler]]]))
----


=== Security

==== Cross-Origin Resource Sharing

Cross-Origin Resource Sharing (CORS) is a mechanism that allows restricted resources (e.g. fonts, JavaScript, etc.) on a web page to be
requested from another domain outside the domain from which the resource originated.

Is often used for allowing API resources to be accessed in a web browser, out of the domain of your web applications.

_Catacumba_ has builtin support for CORS, and this is how you can use it:

[source, clojure]
----
(require '[catacumba.handlers :refer [cors]])

(def cors-conf {:origin #{"http://website.com"}                       ;; mandatory
                :max-age 3600                                         ;; optional
                :allow-headers ["X-Requested-With", "Content-Type"]}) ;; optional

(def app
  (ct/routes [[:prefix "api/v1"
               [:any (cors cors-conf)]
               [:get "foo" some-handler]
               [:post "foo" some-save-handler]]]))
----

The `:origin` key can be a set of possible origins or simply `"*"` to allow all origins.


==== Content Security Policy

Is a security related chain handler that appropriately sets the `Content-Security-Policy` headers.

Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain
types of attacks, including Cross Site Scripting (XSS) and data injection attacks. These attacks are
used for everything from data theft to site defacement or distribution of malware.

Here a simple example on how to use it:

[source, clojure]
----
(def cspconf {:default-src "'self' *.trusted.com"
              :img-src "*"
              :frame-ancestors "'none'"
              :reflected-xss "filter"})

(def app
  (ct/routes [[:prefix "web"
               [:any (csp-headers cspconf)]
               [:get your-handler]]])
----

You can read more about that here: https://developer.mozilla.org/en-US/docs/Web/Security/CSP. The
complete list of directives can be found here: https://developer.mozilla.org/en-US/docs/Web/Security/CSP/CSP_policy_directives

This handler supports the following directives: `:default-src`, `:frame-ancestors`, `:frame-src`,
`:child-src`, `:connect-src`, `:font-src`, `:form-action`, `:img-src`, `:media-src`,  `:object-src`,
and `:reflected-xss`.


==== Frame Options

This is a security related chain handler that adds `X-Frame-Options` header to the response.

The X-Frame-Options HTTP response header can be used to indicate whether or not a browser should
be allowed to render a page in a `<frame>`, `<iframe>` or `<object>` . Sites can use this to avoid
clickjacking attacks, by ensuring that their content is not embedded into other sites.

Example:

[source, clojure]
----
(require '[catacumba.handlers :as handlers])

(def app
  (ct/routes [[:prefix "web"
               [:any (handlers/frame-options-headers {:policy :deny})]
               [:get your-handler]]]))
----

The possible values for the `:policy` key are: `:deny` and `:sameorigin`.

WARNING: The frame-ancestors directive from the CSP Level 2 specification
officially replaces this non-standard header.


==== Strict Transport Security

This is a security related chain handler that adds the `Strict-Transport-Security` header to the response.

HTTP Strict Transport Security (often abbreviated as HSTS) is a security feature that lets a web
site tell browsers that it should only be communicated with using HTTPS, instead of using HTTP.

Usage example:

[source, clojure]
----
(require '[catacumba.handlers :as handlers])

(def app
  (ct/routes [[:prefix "web"
               [:any (handlers/hsts-headers {:max-age 31536000 :subdomains true })]
               [:get your-handler]]]))
----

You can read more about that header here: https://developer.mozilla.org/en-US/docs/Web/Security/HTTP_strict_transport_security


==== Content Type Options

This is a security related chain handler that adds the `X-Content-Type-Options` header to the
response. It prevents resources with invalid media types being loaded as stylesheets or scripts.

This chain handler does not have any additional parameters. Let see an example on how you
can use it:

[source, clojure]
----
(require '[catacumba.handlers :as handlers])

(def app
  (ct/routes [[:prefix "web"
               [:any handlers/content-type-options-headers]
               [:get your-handler]]]))
----


More information:

* http://msdn.microsoft.com/en-us/library/ie/gg622941(v=vs.85).aspx
* https://www.owasp.org/index.php/List_of_useful_HTTP_headers


== Advanced topics

=== Modular components

_Catacumba_ is build from its ground with optional support for the `stuartsierra/component` library, and
exposes a `catacumba-server` component with an API for adding routes and handlers from other components.

Let see a little example on how it can be used:

[source, clojure]
----
(ns yourapp.system
  (:require [com.stuartsierra.component :as component]
            [catacumba.components :refer (catacumba-server assoc-routes!)]))

;; Define your web application component, it will be responsible to setup
;; the routes to the catacumba-server component of your handlers

(defrecord WebApp [server]
  component/Lifecycle
  (start [this]
    (let [routes [[:get "foo" some-handler]
                  [:get "bar" other-handler]]
      (assoc-routes! server ::web routes)))

  (stop [this]
    ;; noop
    ))

;; Define a simple constructor for your web application component
(defn webapp []
  (->WebApp nil))

;; Define the system with two main components: catacumba-server and webapp
;; and explicitly specify the dependency of catacumba-server for webapp/

(defn application-system
  "The application system constructor."
  []
  (-> (component/system-map
       :catacumba (catacumba-server {:port 5050})
       :app (webapp))
      (component/system-using
       {:app {:server :catacumba}})))

;; Just define an entry point for the application.

(defn -main
  "The main entry point to your application."
  [& args]
  (component/start (application-system)))
----

Be aware that each call to the `assoc-routes!` function will cause the server to reload. In the majority of
circumstances this is completely irrelevant because it is done at application bootstrap time.

To understand it better, _catacumba_ comes with an <<sse-component-example,example>> that builds a
multiuser chat using "Server-Sent events" and component, so you can experiment with real code.
See the <<examples,examples>> section for it.


=== Launching the server

As you can see in the quick start section, the main entry point for start the server is
the `run-server` function that receives a handler chain and a map with options.

At this moment, it has a very small subset of options that netty and ratpack offer but is a good
starting point.

.Supported options
[options="header", cols="^1,^1,^2"]
|===========================================================================
| Keyword   | Default | Description
| `:port`   | `5050` | The port to listen on.
| `:threads` | (num of cores * 2) | The number of threads for handler requests.
| `:debug` | `false` | Start in development mode.
| `:setup` | nil    | A callback for configuration step (low level ratpack access).
| `:basedir` | nil | The application base directory, used mainly for resolving relative paths and assets.
|===========================================================================

All supported options of this function, can be overwritten at JVM startup, using environment variables
or system properties. This allows to customize the server without modifying source code and exists for convenience
to make easy customizations in deployments.

For example, you can change the default port on JVM startup using the `CATACUMBA_PORT` environment variable
or `catacumba.port` system property:

.Example using enviroment variables
[source, bash]
----
export CATACUMBA_PORT=8000
export CATACUMBA_BASEDIR=`pwd`
java -jar yourjarhere.jar
----

.Example using enviroment variables
[source, bash]
----
java -Dcatacumba.port=8000 -Dcatacumba.debug=true -jar yourjarhere.jar
----


[[examples]]
== Examples

[[website-example]]
=== Website and Auth

This example tries to show the way to use _catacumba_ in a website like projects, with authentication
and session.

You can see the example code here:
https://github.com/funcool/catacumba/tree/master/examples/website


[[single-file-example]]
=== Single file web app

This example tries to show how you can use _catacumba_ for building small web applications that fits
in one file and execute them like a shell script or an executable.

This example requires http://boot-clj.com/

https://github.com/funcool/catacumba/tree/master/examples/single-file


[[sse-component-example]]
=== Multiuser chat with SSE

This example tries to demonstrate how can you build a simple chat using "Server-Sent Events" for
communicating events to the client and using *stuartsierra/component* for a modular application
architecture.

You can see the example code here:
https://github.com/funcool/catacumba/tree/master/examples/component-chat


=== Debugging with prone

link:https://github.com/magnars/prone[Prone] is really awesome middleware for ring that shows
a beautiful and human readable stack traces when a exception is raised in your application. It is not
directly compatible with _catacumba_ but it is relatively easy to adapt it.

You can see the example code here: https://github.com/funcool/catacumba/tree/master/examples/debugging

NOTE: Obviously, if you are using the ring type of handler, you can use Prone as is, without any
additional adaptation. This example shows how it can be used with _catacimba_'s default handler type.


=== Instrumentation

_Catacumba_ comes with the ability to instrument your application for taking different kinds of diagnosis,
such as performance, latency, etc. This example shows how it can be done.

You can see the example code here: https://github.com/funcool/catacumba/tree/master/examples/interceptor



== FAQ

[[difference-with-aleph]]
=== What is the difference between _catacumba_ and Aleph?

First of all, Aleph is one of the most robust libraries in the Clojure ecosystem for building asynchronous
servers. Here is an incomplete list of differences and motivations why I wrote _catacumba_ instead
of using _aleph_ directly in my applications:

- Aleph with manifold offers good abstractions for creating async servers but they are much too
  low level and only provide the basic building blocks. _catacumba_ intends to be a toolkit that is highly
  focused on web development by providing a good collection of features that matter to web developers.
- I wrote _catacumba_ to have an alternative to ring and _Aleph_ that uses ring's abstractions for
  handling web requests.
- Aleph has a good path to have an easily readable  and user friendly documentation.
- Aleph is build on manifold streams and _catacumba_ uses reactive-streams abstractions.

_Catacumba_ does not intend to be a replacement for it, it simply has different focus.


== Developers Guide

=== Philosophy

Five most important rules:

- Beautiful is better than ugly.
- Explicit is better than implicit.
- Simple is better than complex.
- Complex is better than complicated.
- Readability counts.

All contributions to _catacumba_ should keep these important rules in mind.


=== Contributing

Unlike Clojure and other Clojure contributed libraries _catacumba_ does not have many
restrictions for contributions. Just open an issue or pull request.


=== Source Code

_catacumba_ is open source and can be found on link:https://github.com/funcool/catacumba[github].

You can clone the public repository with this command:

[source,text]
----
git clone https://github.com/funcool/catacumba
----

=== Run tests

For running tests just execute this:

[source, text]
----
boot watch-tests
----


=== License

_catacumba_ is licensed under BSD (2-Clause) license:

----
Copyright (c) 2015 Andrey Antukh <niwi@niwi.nz>

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
----
