= Catacumba - Web toolkit for Clojure.
Andrey Antukh, <niwi@niwi.nz>
v0.5.0
:toc: left
:!numbered:
:idseparator: -
:idprefix:
:source-highlighter: pygments
:pygments-style: friendly
:sectlinks:


== Introduction

_Catacumba_ is an asynchronous and non-blocking web toolkit for Clojure built on top of
ratpack and netty and with design influenced by ring, pedestal and ratpack.


=== Rationale

I start writting this library as a research project to provide a simple, non
obstructive (a la ring) but without constrains of the existing spec (ring spec),
web toolkit for build asynchronous and non-blocking web services.

In the Clojure ecosystem there are several existing solutions for that purpose. For
mention some of them, we have Pedestal, Aleph, Jet, Immutant, etc. With the exception of
Pedestal, the rest are build on top of the ring spec, that something I want exclude from
the equation. And Pedestal is to much high level and opinionated, so it not
fits very well with the initial constraints.

Some detailed explanation of differencies with few of them are explained in the FAQ
section of this documentation.

Here a incomplete list of things that _catacumba_ aims to archieve:

* Have a flexible and extensible way to setup different kind of handlers
* Provide a simple and lightweight approach for defining asynchronous web services with
  support for different abstractions, such as promises, futures, core.async, manifold,
  reactive-streams, ...
* Build almost everything up on abstractions for simple and easy extensibility.
* Provide a built-in, data-based routing.
* To be flexible and not very opinionated.
* Have backpressure support out of the box.

And _catacumba_ goals are not:

* To be a fully integrated full stack solution like immutant or pedestal.
* To provide an opinionated way to structure your "bussines logic"
* To provide all possible features that you might need.
* To be a low level, ring based library.

The result of this research project is an powerfull, lightweight, and fully extensible
asynchronous web toolkit built on top of existing and well designed components such as
Ratpack, Netty, Rective-Streams and core.async.

////
TODO: move this into FAQ section
In the Clojure ecosystem there are several solutions for that purpose: Pedestal, Aleph,
Jet and Immutant. All them are good Clojure libraries/frameworks but none of them
satisfies me for different reasons (some of them explained in the FAQ section).

* The pedestal approach is very opinionated and too much high level and I prefer something
  simple, lightweight and maybe less opinionated.
* Aleph, seems like a great library but lacks good, readable, user friendly documentation
  and its generic approach (not only http) does not help much. If you want read more about
  differences with aleph, see <<difference-with-aleph,this>> faq entry.
* Jet is a asynchronous ring addapter for Jetty 9. It is really great library that I have
  used in some projects, and fits very well on my idea of web toolkit but it has two
  drawbacks, it is build as ring adapter having all the good and all the bad of ring and
  it is using Jetty (Jetty is a servlet server that comes with optional async support, it
  isn't asynchronous from the ground up).
////



=== Project Maturity

Since _catacumba_ is a young project there can be some API breakage.


=== Requirements

_Catacumba_ is only runs with *JDK8* and *Clojure 1.7+* (due to extensive use of
transducers and jdk8 concurrency primitives).


=== Install

This section covers the _catacumba_ library installing process and its requirements.

*Leiningen*

The simplest way to use _catacumba_ in a clojure project, is by including it in the
dependency vector on your *_project.clj_* file:

[source,clojure]
----
[funcool/catacumba "0.5.0"]
----

*Gradle*

If you are using gradle, this is a dependency line for gradle dsl:

[source, groovy]
----
compile "funcool:catacumba:0.5.0"
----

[[quickstart]]
== Quick Start

This section intends to explain how to get _catacumba_ up and running.


=== First handler

The handler consists of a function that accepts a "context" as first parameter and
returns something renderable. Let see an example:

[source, clojure]
----
(defn my-hello-world-handler
  [context]
  "Hello World")
----

The handler may look very familiar if you have used ring previously. The main difference
is that it receives a context object instead of a request object. Additionally it may
return a string directly.

The following sections explain all related concepts and give a full introduction on how
handlers work.


=== Running the server

Now having defined the simple, hello world handler, it is time to run it. To do it,
import the `run-server` function from `catacumba.core` ns and execute it with
handler as first parameter:

[source, clojure]
----
(require '[catacumba.core :as ct])

(ct/run-server my-hello-world-handler)
----

TIP: The `run-server` function does not block and you can execute it in a repl without
problems.


=== Complete example

This is what the complete source code of the example looks like:

[source, clojure]
----
(ns exampleapp.core
  (:require [catacumba.core :as ct])
  (:gen-class))

(defn my-hello-world-handler
  [context]
  "Hello World")

(defn -main
  [& args]
  (ct/run-server my-hello-world-handler))
----

_Catacumba_ also comes with a little collection of <<examples,Examples>> that may help you
setup your first project.


== User Guide

This section intends explain all the different parts of _catacumba_ and how they are
playing together.


=== Handlers

The idea of handlers is a fundamental piece of the _catacumba_ library and this chapter
intends to explain everything related to default handlers.


==== What is a handler?

As we have seen in the "<<Quick Start,quickstart>>" section, a handler mainly consists of
a simple function that acts on the handling context.

Do not worry about the context for now, it will be explained in later sections. The only
thing that you should known about it at this time, is that is the central part of the
request and response lifetime. It stores the current state of the http request and
everything related.

The hello world handler has this aspect:

[source, clojure]
----
(defn myhandler
  [context]
  "Hello World")
----


NOTE: I mention the "default" word because, _catacumba_ comes with different
<<handler-types,types of handlers>> out of the box. The catacumba's handlers system is
fully extensible so you can easyly create your own handler types (also called adapters
the internal terminology).


==== Write to response

As you can observe from the previous example, no status code is being provided, only the
body of the response. To send a complete response you can use a builtin response type or
a ring-like hashmap:

[source, clojure]
----
(require '[catacumba.http :as http])

(defn my-handler
  [context]
  (http/ok "Hello World"))
----

Following output data types are supported for a handler function:

- a *string*, will result in a response with status code 200 and "text/plain" as content
  type.
- a *ring style* hash map.
- a *response* type (very similar to ring one).

The handler's return value is implemented using clojure protocols and its behavior can be
extended easily with user defined types.

Let see an other example, using _catacumba_'s response type with additional header:

[source, clojure]
----
(require '[catacumba.http :as http])

(defn myhandler
  [context]
  (http/ok "<p>Hello World</p>" {:content-type "text/html"}))
----

In the previous examples, we have seen how the return value is handled, but behind the
scenes the context is the responsible of interactions with the request and the response.
Let see the same example but interacti directly with the context:

[source, clojure]
----
(def myhandler
  [context]
  (ct/set-status! context 200)
  (ct/set-headers! context {:content-type "text/plain"})
  (ct/send! context "hello world"))
----

The return value handling is really a helper for people coming from ring. Internally, the
context is the main protagonist in IO operations.


==== Reading the request

As we mentioned previously, the `context` is the central part of the IO operations, so
you can treat it as request and response in the same time.

A context behaves identical to the clojure map and contains the basic request related
attributes such as `:body`, `:query` and `:headers`, among others (explained in other
sections).

===== Body

The request body can retrieved with the `:body` keyword from the `context`.

[source, clojure]
----
(:body request)
;; => <TypedData>
----

The `TypedData` is a ratpack link:http://ratpack.io/manual/current/api/ratpack/http/TypedData.html[internal type]
that represents the http request body.

That object exposes through Java interop methods to access the content type and the raw
data of the request body. For convenience, it implements the `clojure.java.io` protocols
for make it compatible with Clojure's native facilities for reading data.

A good demostration of this is using the clojure `slurp` function. It uses
`clojure.java.io` abstractions behind the scenes and serves as helper for reading a
resource as a string:

[source, clojure]
----
(def myechohandler
  [context]
  (let [^String body (slurp (:body context))]
    (http/ok body)))
----

The `slurp` function uses the abstractions defined on the `clojure.java.io` namespace
for read the content of the provided resourse as string and return it.

Furthermore, _catacumba_ offers a more flexible way to parsing body data based on the
incoming content type, but it is explained with more details in the
<<Body parsing section,body-parsing>> of this document.


===== Headers

Like the http request body, the http headers are available through the `:headers` key
entry. In order to extract some header, just perform the apropiate lookup:

[source, clojure]
----
(get-in context [:headers :origin])
;; => "https://github.com"

If a header has multiple values, the value will be a vector.


===== Cookies

The cookies CRUD operations works very similiar to the headers one. It consists in two
polymorphic functions (`get-cookies` and `set-cookies!`) that can be used directly with
context or with request or response instances.

.Get cookies from request example
[source, clojure]
----
(ct/get-cookies context)
;; => {:cookiename {:value "value" :path "/" :secure false}}
----

.Set cookies in the response
[source, clojure]
----
(ct/set-cookies context {:cookiename {:value "foobar" :max-age 3600}})
----

The cookies map is almost identical to the one that you can find in ring, and has the
following possible properties:

* `:domain` - restrict the cookie to a specific domain
* `:path` - restrict the cookie to a specific path
* `:secure` - restrict the cookie to HTTPS URLs if true
* `:http-only` - restrict the cookie to HTTP if true
                 (not accessible via e.g. JavaScript)
* `:max-age` - the number of seconds until the cookie expires


=== Routing

In contrast to ring, _catacumba_ is a toolkit for web development and offers builtin
support for advanced routing that allows handlers chaining, partitioning, error handling,
among other features.

NOTE: _Catacumba_ has a polymorphic and extensible way to setup handlers, and routing is
one of multiple possible implementations. Is completely optional and you can use any
other routing library if you want.


==== Basic syntax

The routes in _catacumba_ are defined using clojure data structures: vectors and
keywords. Let's see a little example of the aspect in a complete example:

[source, clojure]
----
(def routes
  (ct/routes [[:prefix "api"
               [:get "users" users-handler]]]))

(ct/run-server routes)
----

The order of statements is very important because the routing in _catacumba_ is a simple
chain or pipeline. Each handler has the ability to delegate the request handling to the
next handler in the pipeline.

This is a complete list of route directives that you can use a part of `:get`:  `:any`
(matches all routes, often used for add chain handlers), `:post`, `:put`, `:patch` and
`:delete`.


==== Dispatch by method

In some circumstances you may want have different handlers depending on the HTTP method
used for one concrete endpoint. For this purpose there is the `:by-method` route
directive:

[source, clojure]
----
(ct/routes [:prefix "api/users"
            [:by-method
             {:get list-users-handler
              :post create-users-handler}]])
----


==== Routing params

_catacumba_'s routing also allows to capture URL values encoded in the URL or as URL
parameters using special symbols. For example, the path string "foo/:val" will match paths
such as "foo/bar", "foo/123".  The matched parameters are automatically populated to the
context under the `:route-params` keys.

[source, clojure]
----
(def article-detail
  [context]
  (let [id (get-in context [:route-params :id])]
    (http/ok (str "You have requested article with id=" id))))

(def app
  (ct/routes [[:get "articles/:id" article-detail]]))
----

Additionally to the basic token for representing URL parameters, _catacumba_ also allows
the use of regular expressions for delimiting the input or marking a URL token optional.

See the following table for all supported URL tokens:

.Supported url matching tokens
[options="header", cols="2,3,3,2"]
|===========================================================================
| Path Type | Syntax | Route example | Matching url example
| Literal | `foo` | `[:get "foo" handler]` | `/foo`
| Mandatory | `:«token-name»` | `[:get "foo/:param" handler]` | `/foo/bar`
| Optional | `:«token-name»?` | `[:get "foo/:param?" handler]` | `/foo` and `/foo/bar`
| Mandatory & Regex | `:«token-name»:«regex»` | `[:get "foo/:id:\d+" handler]` | `/foo/2`
| Optional & Regex | `:«token-name»?:«regex»` | `[:get "foo/:id?:\d+" handler]` | `/foo/2` and `/foo`
|===========================================================================


==== Routing chain

The chaining of handlers can be done in two different ways:

- *inline*: providing more that one handler for concrete http method.
- *multiple routes*: providing a "match all" handler at the start of prefix.

Chaining handlers inline follows this pattern:

[source, clojure]
----
(ct/routes [[:get "users" permission-check-handler get-users-handler]])
----

Additionally, you can setup "catch all" handlers at the start of a routing definition and
use them as interceptors:

[source, clojure]
----
(def routes
  (ct/routes [[:prefix "api"
               [:any authentication-handler]
               [:get "users" users-handler]]]))
----

For a better understanding of how the handler delegation chain works, see the *Context*
chapter.


==== Error handling

The _catacumba_ router chain allows to setup user defined error handling functions. This
requires a very, very simple setup, you only have to add another route entry with using
`:error` route directive:

[source, clojure]
----
(def routes
  (ct/routes [[:error my-error-handler]
              [:get "users" users-handler]]))
----

With the previous code we have set up a global error handler, applying to all routes in
the chain. But there is also the possibility to set different error handlers for different
prefixes:

[source, clojure]
----
(def routes
  (ct/routes [[:prefix "api"
               [:error my-error-handler-for-this-prefix]
               [:any authentication-handler]
               [:get "users" users-handler]
               [:put "users" check-permissions-handler update-users-hander]]
              [:prefix "admin"
               [:error my-error-handler-for-this-other-prefix]
               [:get "dashboard" my-dashboard-handler]]]))
----

The error handler signature is very similar to standard HTTP handler signature, with the
difference being that it receives the throwable instance as an additional parameter:

[source, clojure]
----
(defn my-error-handler
  [context error]
  (http/internal-server-error (.getMessage error)))
----

==== Serving static files

_Catacumba_ also comes with the ability to serve static files. This is can be done using
:assets routing directive. Here an example:

[source, clojure]
----
(ct/routes [[:assets "assets" {:dir "public/assets"}]])
----

Additionally, it has support for specify a index file, that will be returned if no
file is requested. This is very usefull for SPA (single page applications):

[source, clojure]
----
(ct/routes [[:assets "assets" {:dir "public/assets"
                               :indexes ["index.html"]}]])
----

So, if you make a http request to `/assets/` the `index.html` will be automatically
returned.


=== Context

Another core part of _catacumba_ is the *Context*.

Just like in ratpack, the context in _catacumba_ has following responsbibilities:

* Provide direct access to the request and response objects.
* Access to the contextual objects (called registry).
* Flow control in handler chaining.
* Convenience helpers for common handlers operation.


==== Handler delegation

In other words, it can be explained as "flow control" in the chain of handlers.

In _catacumba_, the request process is an asynchronous pipeline of handlers that can be
composed in different ways (as we previously seen in a router section). So the each
handler in the pipeline has the ability to do some work and delegate the rest of
processing to next handler (in the chain/pipeline).

This approach allows you build different kind of modular and completelly decoupled
handlers and compose them into a pipeline to work together.

The delegation can be done with `delegate` function. Let see a simple example:

[source, clojure]
----
(defn handler1
  [context]
  (do-something context)
  (ct/delegate context))

(defn handler2
  [context]
  (http/ok "hello world"))

(def router
  (ct/routes [[:get "foo" handler1 handler2]]))
----

In this example, when the request arrives at `handler1`, it delegates the execution to
the next handler in the chain. It do not need to know about next handler, it just
delegates to the routing chain to find a next handler or raise a corresponding error.

In addition to the simple handler delegation, _catacumba_ offers a simple way to pass
context data to the next handler in the chain. It can be done by passing an additional
parameter to the `delegate` function:

[source, clojure]
----
(defn handler1
  [context]
  (do-something context)
  (ct/delegate context {:message "foobar"}))

(defn handler2
  [context]
  (let [message (:message context)]
    (http/ok message)))
----

In the example above, the second handler prints the message found in the context.


[[handler-types]]
== Handler types

This section intends to explain the different kind of builting handler types.

=== Asynchronous

Asynchronous handlers are handlers that return a value in an asynchronous way using one
of the supported abstractions, such as core.async, reactive-streams and many others
(explained below).


==== Channels

The `core.async` channel is one of the supported abstractions that comes with _catacumba_
out of the box. It consists of a handler that returns a body as a channel or response as
a channel.

This is the aspect of async handler returning the channel as a body:

[source, clojure]
----
(defn my-async-handler
  [context]
  (let [ch (chan)]
    (go
      (dotimes [i 10]
        (<! (timeout 500))
        (>! ch (str i "\n")))
      (close! ch))
    (http/ok ch)))
----

Returning a channel as the body has the advantage that you have the ability of setting
additional headers and HTTP status in your function body code. But, if you are return a
channel as a response value, the default status code will be set for you. The behavior of
two approaches is the same, resulting in a chunked encoded response to the client.

And this is an example of an async handler returning a channel as response:

[source, clojure]
----
(defn my-async-handler
  [context]
  (go
    (let [result (<! (do-some-async-task))]
      (:message result)))
----

Do not worry about how much data you can send to the client, if you are using channels in
a right way (in a go block), you will send data to the client as fast as the client can
consume it. This technique is also called backpressure, and is fully supported for
chunked responses.


==== Promises

Promises are another abstraction supported out of the box in _catacumba_. It comes from
the link:https://github.com/funcool/promissum[promissum library] and is build on top of
JDK8 _CompletableFuture_.

Sometimes, you do not need send a chunked stream to the client, but your "bussines logic"
is defined in an asynchronous friendly API using promises (or something similar). In this
case, with _catacumba_ you can return a promise as a body or as a response and the data
will be sent to the client when the promise has been resolved successfully.

[source, clojure]
----
(require '[promissum.core :as p])

(defn my-async-handler
  [context]
  (let [promise (p/promise "hello world")]
    (http/ok promise {:content-type "text/plain"})))
----

Thanks to the link:https://github.com/funcool/cats[cats] `mlet` macro, that allows us
structure pure async code in a synchronous way:

[source, clojure]
----
(require '[promissum.core :as p])
(require '[cats.core :as m])

(defn my-async-handler
  [context]
  (m/mlet [a (something-that-returns-promise context)
           b (do-something-with a)]
    (m/return (do-other-thing-with b)))
----

The result of `mlet` macro expression will be a *promise* with the eventually available
result from `(do-other-thing-with b)` expression.


==== Manifold

The link:https://github.com/ztellman/manifold[manifold] library offers different kind of
deferred and stream abstractions for Clojure and you can use both them as response or body
of the response for sending data to the client asynchronously.

[source, clojure]
----
(require '[manifold.deferred :as d])

(defn my-async-handler
  [context]
  (let [result (d/future (Thread/sleep 1000) "hello world")]
    (http/ok result {"content-type" "text/plain"})))
----


==== Reactive Streams

This is the core of all abstractions, and support for it comes out of the box from
*ratpack*. All other abstractions that we have seen are always coerced to a *Publisher*
instance before sending it to the client.

Here there isn't anything  new to explain, if you have a function that return some kind
of *Publisher*, you can return it as response or send it as body like as usual.

Let see an example:

[source, clojure]
----
(require '[catacumba.stream :as stream])
(require '[cuerdas.core :as str])

(defn my-async-handler
  [context]
  (let [pub (->> (stream/publisher ["hello" " " "world"])
                 (stream/publisher (map str/upper)))]
    (http/ok pub)))

;; It will return a chunked response to the client with "HELLO WORLD" string.
----


=== Websockets

One of the main goals of _catacumba_ is come with builtin, full featured and
backpressure-aware websockets support.

You can start a websocket connection in any _catacumba_ handler or route handler using
`websocket` function. It does not require any special handlers for dealing with
websockets. Let see an example:

[source, clojure]
----
(defn my-websocket-echo-handler
  [{:keys [in out]}]
  (go-loop []
    (if-let [received (<! in)]
      (do
        (>! out received)
        (recur))
      (close! out))))

(defn my-handler
  [context]
  (ct/websocket context my-websocket-echo-handler))

(def route
  (ct/routes [[:prefix "events"
               [:any my-handler]]]))
----


Additionally, _catacumba_ offers a a way to set up a websocket handler directly, without
an additional step in the default handler:

[source, clojure]
----
(defn echo-handler
  "This is my echo handler that serves as
  a websocket handler example."
  {:handler-type :catacumba/websocket}
  [{:keys [in out]}]
  (go-loop []
    (if-let [received (<! in)]
      (do
        (>! out received)
        (recur))
      (close! out))))

(def route
  (ct/routes [[:prefix "events"
               [:any #'echo-handler]]]))
----

As you can observe, for any function has additional metadata that indicates to _catacumba_
that this function is a websocket type handler, _catacumba_ will bootstrap the websocket
connection for you.

Is very important pass a var reference to the router instead of the function directly,
because the metadata defined in the function is bound to the var and not to the function.

Also, you can attach metadata inline, using the `with-meta` Clojure built-in function:

[source, clojure]
----
(ct/routes [[:prefix "events"
             [:any (with-meta echo-handler
                     {:handler-type :catacumba/websocket})]]])
----

Clojure offers a lot of flexibility for working with metadata so you can set the handler
type in the way that you prefer.


=== SSE (Server-Sent Events)

WebSockets are cool because they allow bi-directional comunication, but in some
circumstances we only need something unidirectional, for notifying the client about some
changes or any other events. For this purpose exists
link:https://developer.mozilla.org/en-US/docs/Server-sent_events[Server-Sent Events] (SSE)
and _catacumba_ also has support for it.

The handler for SSE does not differs a lot from websockets that we have seen in the
previous section. The main difference is that the reception of the data is not allowed.

[source, clojure]
----
(defn time-notification
  "Handler that notifies each second
  the current server time to the client."
  {:handler-type :catacumba/sse}
  [context out]
  (go-loop []
    (when-let [_ (>! out (str (java.time.Instant/now)))]
      (<! (timeout 1000))
      (recur))))

(def route
  (ct/routes [[:prefix "events"
               [:any #'time-notification]]]))

----

In a similar way to websockets, you can start SSE in any place, such as a standard
_catacumba_ handler:

[source, clojure]
----
(defn time-notification
  "Handler that notifies each second
  the current server time to the client."
  [context]
  (ct/sse context
          (fn [_ out]
            (go-loop []
              (when-let [_ (>! out (str (java.time.Instant/now)))]
                (<! (timeout 1000))
                (recur))))))

(def route
  (ct/routes [[:prefix "events"
               [:any time-notification]]]))

----

Let see some examples how you can send other parameters than simple data:

[source, clojure]
----
;; Send data
(>! out "data as string")
(>! out {:data "data as string"})

;; Send data with event name
(>! out {:data "data as string" :event "foobar"})

;; Set id
(>! out {:id "2"})
----

NOTE: The _catacumba_'s SSE support uses core.async channels, but if you are not happy
with core.async and want use something different (such as manifold streams), you may want
know that everything in _catacumba_ is implemented using abstractions and to implement
your own SSE type of handler that uses manifold streams is very easy.


=== Ring (Compatibility layer)

Although ring support is not first citizen in _catacumba_, the current design of it allows
to create an handler adapter that follows the ring specification. This is a great example
of extensibility of _catacumba_.

Let see how it can be done:

[source, clojure]
----
(defn myringhandler
  "My example ring handler."
  {:handler-type :catacumba/ring}
  [request]
  {:status 200
   :body "hello world"})

;; As standalone handler
(ct/run-server #'myringhandler)

;; Or in a _catacumba_ routing chain
(-> (ct/routes [[:get #'myringhandler]])
    (ct/run-server))
----

Ring handlers can be set as standalone handlers (mainly for using them with compojure and
all related middlewares) or in a _catacumba_'s routing chain.


=== CPS (Continuation-passing style)

TBD


== Built-in Handlers

This section will cover different kind of built-in additional handlers to make the
experience of using _catacumba_ more pleasant.


[[body-parsing]]
=== Body parsing

_Catacumba_ comes with builtin support for conditional body parsing depending on the
incoming content type. It consists of a routing chain that adds the `:body` entry in the
context with the parsed data or `nil` in case of an incoming content type does not have an
attached parser implementation.

In order to use it, it is simple as prepending the `body-params` handler to your route
chain:

[source, clojure]
----
(require '[catacumba.handlers :as hs])

(defn example-handler
  [context]
  (let [body (:body context)]
    (println "Received body:" body)
    (http/no-content)))

(def app
  (ct/routes [[:any (hs/body-params)]
              [:any example-handler]]))

;; ...
----

By default, the `application/x-www-form-urlencoded`, `multipart/form-data` and
`application/json` parsers come out of the box. The
link:https://github.com/dakrone/cheshire[cheshire] json parser is used for parsing the
body with the `application/json` content type.

The body parsing is a open system, implemented using clojure's polymorphism facilites
such as multimethods. If you want add additional parser, is as simple as adding an
implementation to the `parse` multimethod with your content-type as dispatch tag.

[source, clojure]
----
(require '[catacumba.handlers.parsing :as parsing])
(import 'ratpack.http.TypedData
        'ratpack.handling.Context)

(defmethod parsing/parse :application/xml
  [^Context ctx ^TypedData body]
  ;; your parsing logic here
  )
----

=== Autoreload

The autoreload handler consist in a very simple concept: reload all modified namespaces
on each request. If you are familiar with the ring reload middleware, this one works
in almost identical way.

For use it, just attach it to your routing chain:

[source, clojure]
----
(require '[catacumba.handlers :as hs])

(def app
  (ct/routes [[:any (hs/autoreloader)]
              [:get "foo" #'somens/your-handler]
              [:get "bar" #'somens/other-handler]
              [:post ...]]))
----

You can see a working example in the <<website-example,Website example>> code.


=== Sessions

==== Getting Started

The HTTP sessions in _catacumba_ are also implemented as chain handler. So you can add
session handling support to you application just by adding the handler to your routing
chain:

[source, clojure]
----
(require '[catacumba.handlers :as hs])

(def app
  (ct/routes [[:any (hs/session {:storage :inmemory})]
              [:get your-handler]]))
----

All handlers in the route pipeline that are going after the session handler will come
with `:session` key in the context with a "atom" like object. You just treat it as atom,
so for attaching some data to the session you should use the well known `swap!` function:

[source, clojure]
----
(defn my-handler
  [context]
  (let [session (:session context)]
    (swap! session assoc :userid 1)
    "my response"))
----

You can clean the session just reseting to the empty map:

[source, clojure]
----
(reset! session {})
----

One of the big advantages of using the routing chain for session set up, is that you can
restrict session halding to a concrete subset of urls/resources avoiding unnecesary code
execution for handlers that do not need sessions:

[source, clojure]
----
(def app
  (ct/routes [[:prefix "admin"
               [:any (hs/session {:storage :inmemory})]
               [:get your-handler]]
              [:prefix "api"
               [:get "users" other-handler]
               [:get ...]]]))
----


==== Session storages

Currently _catacumba_ comes with one basic session storage, the `:inmemory`. But the
session storage system is pluggable and is defined in terms of the following protocol:

[source, clojure]
----
(defprotocol ISessionStorage
  (read-session [_ key])
  (write-session [_ key data])
  (delete-session [_ key]))
----

If you are familiar with the ring based session storages, you can observe that the
_catacumba_ session storage abstraction is almost identical to the ring session
abstraction, so migrating from or adapting the ring session storages is really easy. The
unique difference is that functions should return a promise (from promissum library).

To use a concrete session storage, just pass a instance of it as value of the `:storage`
key in a session handler constructor:

[source, clojure]
----
(hs/session {:storage (my-storage-constructor)})
----

If you want implement own session storage, take a look to the `:inmemory` builtin one.


=== Authentication

_Catacumba_ also comes with authentication facilites heavily inspired by *buddy-auth*.

We do not have used directly *buddy-auth* because it is designed for ring based
applications, therefore the buddy-auth abstractions are blocking, and blocking api is not
well suited for async based applications.

So, _catacumba_ defines own abstractions for handle authentication, that are very very
similar to the _buddy-auth_, with the execption that them expose asynchronous api, so
adapt existing _buddy-auth_ backends should be very easy.

Like *buddy-auth*, _catacumba_ comes with a little set of builtin backends that can be
used directly: *session*, *jws* (token) and *jwe* (encrypted token).


==== Session

Let start with session authentication backend. This backend is mainly used for web based
applications and consists in verify some value on the session. So this is the easyest
authentication scheme and fits perfectly for the first contact.

Start importing some needed namespaces and create an instance
of the authentication backend:
[source, clojure]
----
(require '[catacumba.http :as http])
(require '[catacumba.handlers :as hs])
(require '[catacumba.handlers.auth :as auth])

(def auth-backend
  (auth/session-backend))
----

Now, continue defining a handler for the login action. It consists in receive credentials
from the user input and verify them. In case of success verifycation, we just need setup
the `:identity` key in the session.

Let see a partially implemented example:

[source, clojure]
----
(defn login-handler
  [context]
  (let [data (:body context)
        user (find-user (:username data)   ;; (implementation ommited)
                        (:password data))]
    (swap! (:session context) assoc :identity user)
    (http/ok "ok")))
----

In order to start using auth facilities in your application, you should add the
authentication handler to the routing chain:

[source, clojure]
----
;; The application routes definition with session, auth and body
;; parsing chain handlers

(def app
  (ct/routes [[:any (hs/session {:storage :inmemory})] ;; Http Session
              [:any (hs/auth auth-backend)]            ;; Auth backend
              [:any (hs/body-params)]                  ;; Body parsing
              [:get "login" login-handler]
              [:get some-handler]]))                   ;; (implementation ommited)
----

You can see a working example using auth facilities <<website-example,here>>.


==== JWS Token

This authentication backend consists in use self contained tokens for authenticate the
user. It behaves very similar to the session one but instead of strong the user
information in a server storage, it stores it directly in a token, enabling so, completely
stateless authentication.

NOTE: The security and the implementation of cryptographic primitives for that token is
relied to the *buddy-sign* library (an other module of buddy) that implements the JWS
specification. That library should be used for generate JWS tokens.

Let start creating a backend instance:

[source, clojure]
----
(def secret "mysecret")
(def auth-backend
  (auth/jws-backend {:secret secret}))
----

Following of our new login handler:

[source, clojure]
----
(require '[buddy.sign.jws :as jws])
(require '[cheshire.core :as json])

(defn login-handler
  [context]
  (let [data (:body context)
        user (find-user (:username data)   ;; (implementation ommited)
                        (:password data))]
    (-> (json/encode {:token (jws/sign {:user (:id user)} secret)})
        (http/ok {:content-type "application/json"}))))
----

And finally, put the new backend into the routing chain:

[source, clojure]
----
(def app
  (ct/routes [[:any (hs/auth auth-backend)]            ;; Auth backend
              [:any (hs/body-params)]                  ;; Body parsing
              [:get "login" login-handler]
              [:get some-handler]]))                   ;; (implementation ommited)
----


WARNING: Take care that using jws for create tokens, the data is serialized using
json + base64 and siged using strong cryptography signatures. That method ensure that
the data can not be manipulated by third party but it not protect it from privacy. If
you need store private data in the token, consider using JWE.


==== JWE Token

This authentication backend consists in using self contained tokens for authenticate the
user. It works identically to the JWS (explained previously) with the exception that
instead of only signing data, it also encrypts the data, so ensuring the data privacy.

You can create the backend instance so:

[source, clojure]
----
(require '[buddy.sign.jwe :as jwe])
(require '[buddy.core.keys :as keys])

(def pubkey (keys/public-key "pubkey.pem"))
(def privkey (keys/private-key "privkey.pem" "thekeysecret"))

(def auth-backend
  (auth/jwe-backend privkey))
----

NOTE: In this example we use asymetric encryption scheme, if you want use an other
encryption scheme, please check
link:https://funcool.github.io/buddy-sign/latest/#_json_web_encryption[buddy-sign documentation]
for the complete list of supported encryption algorithms.

The login handler is almost identical:

[source, clojure]
----
(require '[buddy.sign.jws :as jws])
(require '[cheshire.core :as json])

(defn login-handler
  [context]
  (let [data (:body context)
        user (find-user (:username data)   ;; (implementation ommited)
                        (:password data))]
    (-> (json/encode {:token (jwe/encrypt {:user (:id user)} pubkey)})
        (http/ok {:content-type "application/json"}))))
----

Instead of signing the content, we encrypt it using the public key. The routing chain is
completelly identical from the JWE Token examples.


==== Other

If you not happy with the builtin auth facilities, the _catacumba_'s handler system is
very flexible and you really don't need to use _buddy_. You can write your own auth
facilities and attach them to _catacumba_ using the routing chain.


=== Context as Request

By default, the _catacumba_'s context allows you direct access to the request and
response, both which are instances of classes defined in Ratpack. These classes allows
you to access all related properties such as headers, the request body, the request
method, etc.

But _catacumba_ additionally offers a small set of helper functions for interacting with
that data: getting/setting headers and reading the body (explained in previous sections).

To compensate for this, _catacumba_ comes with a special chain handler that populates the
context with basic request properties such as, headers, path and method:

[source, clojure]
----
(require '[catacumba.handlers :refer [basic-request]])

(def app
  (ct/routes [[:prefix "api/v1"
               [:any basic-request]
               [:get "foo" some-handler]
               [:post "foo" some-save-handler]]]))
----


=== Security

==== Cross-Origin Resource Sharing

Cross-Origin Resource Sharing (CORS) is a mechanism that allows restricted resources (e.g.
fonts, JavaScript, etc.) on a web page to be requested from another domain outside the
domain from which the resource originated.

Is often used for allowing API resources to be accessed in a web browser, out of the
domain of your web applications.

_Catacumba_ has builtin support for CORS, and this is how you can use it:

[source, clojure]
----
(require '[catacumba.handlers :refer [cors]])

(def cors-conf {:origin #{"http://website.com"}                       ;; mandatory
                :max-age 3600                                         ;; optional
                :allow-headers ["X-Requested-With", "Content-Type"]}) ;; optional

(def app
  (ct/routes [[:prefix "api/v1"
               [:any (cors cors-conf)]
               [:get "foo" some-handler]
               [:post "foo" some-save-handler]]]))
----

The `:origin` key can be a set of possible origins or simply `"*"` to allow all origins.


==== Content Security Policy

Is a security related chain handler that appropriately sets the `Content-Security-Policy`
headers.

Content Security Policy (CSP) is an added layer of security that helps to detect and
mitigate certain types of attacks, including Cross Site Scripting (XSS) and data injection
attacks. These attacks are used for everything from data theft to site defacement or
distribution of malware.

Here a simple example on how to use it:

[source, clojure]
----
(def cspconf {:default-src "'self' *.trusted.com"
              :img-src "*"
              :frame-ancestors "'none'"
              :reflected-xss "filter"})

(def app
  (ct/routes [[:prefix "web"
               [:any (csp-headers cspconf)]
               [:get your-handler]]])
----

You can read more about that here:
https://developer.mozilla.org/en-US/docs/Web/Security/CSP. The complete list of directives
can be found here:
https://developer.mozilla.org/en-US/docs/Web/Security/CSP/CSP_policy_directives

This handler supports the following directives: `:default-src`, `:frame-ancestors`,
`:frame-src`, `:child-src`, `:connect-src`, `:font-src`, `:form-action`, `:img-src`,
`:media-src`,  `:object-src`, and `:reflected-xss`.


==== Frame Options

This is a security related chain handler that adds `X-Frame-Options` header to the
response.

The X-Frame-Options HTTP response header can be used to indicate whether or not a browser
should be allowed to render a page in a `<frame>`, `<iframe>` or `<object>` . Sites can
use this to avoid clickjacking attacks, by ensuring that their content is not embedded
into other sites.

Example:

[source, clojure]
----
(require '[catacumba.handlers :as handlers])

(def app
  (ct/routes [[:prefix "web"
               [:any (handlers/frame-options-headers {:policy :deny})]
               [:get your-handler]]]))
----

The possible values for the `:policy` key are: `:deny` and `:sameorigin`.

WARNING: The frame-ancestors directive from the CSP Level 2 specification officially
replaces this non-standard header.


==== Strict Transport Security

This is a security related chain handler that adds the `Strict-Transport-Security` header
to the response.

HTTP Strict Transport Security (often abbreviated as HSTS) is a security feature that
lets a web site tell browsers that it should only be communicated with using HTTPS,
instead of using HTTP.

Usage example:

[source, clojure]
----
(require '[catacumba.handlers :as handlers])

(def app
  (ct/routes [[:prefix "web"
               [:any (handlers/hsts-headers {:max-age 31536000 :subdomains true })]
               [:get your-handler]]]))
----

You can read more about that header here:
https://developer.mozilla.org/en-US/docs/Web/Security/HTTP_strict_transport_security


==== Content Type Options

This is a security related chain handler that adds the `X-Content-Type-Options` header to
the response. It prevents resources with invalid media types being loaded as stylesheets
or scripts.

This chain handler does not have any additional parameters. Let see an example on how you
can use it:

[source, clojure]
----
(require '[catacumba.handlers :as handlers])

(def app
  (ct/routes [[:prefix "web"
               [:any handlers/content-type-options-headers]
               [:get your-handler]]]))
----


More information:

* http://msdn.microsoft.com/en-us/library/ie/gg622941(v=vs.85).aspx
* https://www.owasp.org/index.php/List_of_useful_HTTP_headers


== Advanced topics

=== Modular components

_Catacumba_ is build from its ground with optional support for the
`stuartsierra/component` library, and exposes a `catacumba-server` component with an API
for adding routes and handlers from other components.

Let see a little example on how it can be used:

[source, clojure]
----
(ns yourapp.system
  (:require [com.stuartsierra.component :as component]
            [catacumba.components :refer (catacumba-server assoc-routes!)]))

;; Define your web application component, it will be responsible to setup
;; the routes to the catacumba-server component of your handlers

(defrecord WebApp [server]
  component/Lifecycle
  (start [this]
    (let [routes [[:get "foo" some-handler]
                  [:get "bar" other-handler]]
      (assoc-routes! server ::web routes)))

  (stop [this]
    ;; noop
    ))

;; Define a simple constructor for your web application component
(defn webapp []
  (->WebApp nil))

;; Define the system with two main components: catacumba-server and webapp
;; and explicitly specify the dependency of catacumba-server for webapp/

(defn application-system
  "The application system constructor."
  []
  (-> (component/system-map
       :catacumba (catacumba-server {:port 5050})
       :app (webapp))
      (component/system-using
       {:app {:server :catacumba}})))

;; Just define an entry point for the application.

(defn -main
  "The main entry point to your application."
  [& args]
  (component/start (application-system)))
----

Be aware that each call to the `assoc-routes!` function will cause the server to reload.
In the majority of circumstances this is completely irrelevant because it is done at
application bootstrap time.

To understand it better, _catacumba_ comes with an <<sse-component-example,example>> that
builds a multiuser chat using "Server-Sent events" and component, so you can experiment
with real code. See the <<examples,examples>> section for it.


=== Launching the server

As you can see in the quick start section, the main entry point for start the server is
the `run-server` function that receives a handler chain and a map with options.

At this moment, it has a very small subset of options that netty and ratpack offer but is
a good starting point.

.Supported options
[options="header", cols="^1,^1,^2"]
|===========================================================================
| Keyword   | Default | Description
| `:port`   | `5050` | The port to listen on.
| `:threads` | (num of cores * 2) | The number of threads for handler requests.
| `:debug` | `false` | Start in development mode.
| `:setup` | nil    | A callback for configuration step (low level ratpack access).
| `:basedir` | nil | The application base directory, used mainly for resolving relative paths and assets.
|===========================================================================

All supported options of this function, can be overwritten at JVM startup, using
environment variables or system properties. This allows to customize the server without
modifying source code and exists for convenience to make easy customizations in
deployments.

For example, you can change the default port on JVM startup using the `CATACUMBA_PORT`
environment variable or `catacumba.port` system property:

.Example using enviroment variables
[source, bash]
----
export CATACUMBA_PORT=8000
export CATACUMBA_BASEDIR=`pwd`
java -jar yourjarhere.jar
----

.Example using enviroment variables
[source, bash]
----
java -Dcatacumba.port=8000 -Dcatacumba.debug=true -jar yourjarhere.jar
----


[[examples]]
== Examples

[[website-example]]
=== Website and Auth

This example tries to show the way to use _catacumba_ in a website like projects, with
authentication and session.

You can see the example code here:
https://github.com/funcool/catacumba/tree/master/examples/website


[[single-file-example]]
=== Single file web app

This example tries to show how you can use _catacumba_ for building small web applications
that fits in one file and execute them like a shell script or an executable.

This example requires http://boot-clj.com/

https://github.com/funcool/catacumba/tree/master/examples/single-file


[[sse-component-example]]
=== Multiuser chat with SSE

This example tries to demonstrate how can you build a simple chat using
"Server-Sent Events" for communicating events to the client and using
*stuartsierra/component* for a modular application architecture.

You can see the example code here:
https://github.com/funcool/catacumba/tree/master/examples/component-chat


=== Debugging with prone

link:https://github.com/magnars/prone[Prone] is really awesome middleware for ring that
shows a beautiful and human readable stack traces when a exception is raised in your
application. It is not directly compatible with _catacumba_ but it is relatively easy to
adapt it.

You can see the example code here:
https://github.com/funcool/catacumba/tree/master/examples/debugging

NOTE: Obviously, if you are using the ring type of handler, you can use Prone as is,
without any additional adaptation. This example shows how it can be used with
_catacumba_'s default handler type.


=== Instrumentation

_Catacumba_ comes with the ability to instrument your application for taking different
kinds of diagnosis, such as performance, latency, etc. This example shows how it can be
done.

You can see the example code here:
https://github.com/funcool/catacumba/tree/master/examples/interceptor



== FAQ

[[difference-with-aleph]]
=== What is the difference between _catacumba_ and Aleph?

First of all, Aleph is one of the most robust libraries in the Clojure ecosystem for
building asynchronous servers. Here is an incomplete list of differences and motivations
why I wrote _catacumba_ instead of using _aleph_ directly in my applications:

- Aleph with manifold offers good abstractions for creating async servers but they are
  much too low level and only provide the basic building blocks. _catacumba_ intends to be
  a toolkit that is highly focused on web development by providing a good collection of
  features that matter to web developers.
- I wrote _catacumba_ to have an alternative to ring and _Aleph_ that uses ring's
  abstractions for handling web requests.
- Aleph has a good path to have an easily readable  and user friendly documentation.
- Aleph is build on manifold streams and _catacumba_ uses reactive-streams abstractions.

_Catacumba_ does not intend to be a replacement for it, it simply has different focus.


== Developers Guide

=== Philosophy

Five most important rules:

- Beautiful is better than ugly.
- Explicit is better than implicit.
- Simple is better than complex.
- Complex is better than complicated.
- Readability counts.

All contributions to _catacumba_ should keep these important rules in mind.


=== Contributing

Unlike Clojure and other Clojure contributed libraries _catacumba_ does not have many
restrictions for contributions. Just open an issue or pull request.


=== Source Code

_catacumba_ is open source and can be found on
link:https://github.com/funcool/catacumba[github].

You can clone the public repository with this command:

[source,text]
----
git clone https://github.com/funcool/catacumba
----

=== Run tests

For running tests just execute this:

[source, text]
----
lein test
----


=== License

_catacumba_ is licensed under BSD (2-Clause) license:

----
Copyright (c) 2015 Andrey Antukh <niwi@niwi.nz>

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
----
